// src/WalletContext.tsx
import {
  createContext,
  useCallback,
  useContext,
  useEffect as useEffect2,
  useMemo,
  useState as useState2
} from "react";

// src/useWalletAdapters.ts
import {
  isWalletProvider,
  resolveAdapters
} from "@mysten/wallet-adapter-base";
import { useEffect, useState } from "react";
function useWalletAdapters(adapterAndProviders) {
  const [wallets, setWallets] = useState(
    () => resolveAdapters(adapterAndProviders)
  );
  useEffect(() => {
    const providers = adapterAndProviders.filter(isWalletProvider);
    if (!providers.length)
      return;
    setWallets(resolveAdapters(adapterAndProviders));
    const listeners = providers.map(
      (provider) => provider.on("changed", () => {
        setWallets(resolveAdapters(adapterAndProviders));
      })
    );
    return () => {
      listeners.forEach((unlisten) => unlisten());
    };
  }, [adapterAndProviders]);
  return wallets;
}

// src/WalletContext.tsx
import { jsx } from "react/jsx-runtime";
var DEFAULT_STORAGE_KEY = "preferredSuiWallet";
var WalletConnectionStatus = /* @__PURE__ */ ((WalletConnectionStatus2) => {
  WalletConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  WalletConnectionStatus2["CONNECTING"] = "CONNECTING";
  WalletConnectionStatus2["CONNECTED"] = "CONNECTED";
  WalletConnectionStatus2["ERROR"] = "ERROR";
  return WalletConnectionStatus2;
})(WalletConnectionStatus || {});
var WalletContext = createContext(null);
var WalletProvider = ({
  children,
  adapters,
  autoConnect = true
}) => {
  const wallets = useWalletAdapters(adapters);
  const [status, setStatus] = useState2("DISCONNECTED" /* DISCONNECTED */);
  const [wallet, setWallet] = useState2(null);
  const connected = status === "CONNECTED" /* CONNECTED */;
  const connecting = status === "CONNECTING" /* CONNECTING */;
  const isError = status === "ERROR" /* ERROR */;
  const disconnect = useCallback(async () => {
    wallet == null ? void 0 : wallet.disconnect();
    setStatus("DISCONNECTED" /* DISCONNECTED */);
    setWallet(null);
    localStorage.removeItem(DEFAULT_STORAGE_KEY);
  }, []);
  useEffect2(() => {
    if (connected && wallet) {
      localStorage.setItem(DEFAULT_STORAGE_KEY, wallet.name);
    }
  }, [wallet, connected]);
  const select = useCallback(
    async (name) => {
      let selectedWallet = wallets.find((wallet2) => wallet2.name === name) ?? null;
      setWallet(selectedWallet);
      if (selectedWallet && !selectedWallet.connecting) {
        try {
          setStatus("CONNECTING" /* CONNECTING */);
          await selectedWallet.connect();
          setStatus("CONNECTED" /* CONNECTED */);
        } catch (e) {
          console.log("Wallet connection error", e);
          setStatus("ERROR" /* ERROR */);
        }
      } else {
        setStatus("DISCONNECTED" /* DISCONNECTED */);
      }
    },
    [wallets]
  );
  useEffect2(() => {
    if (!wallet && !connected && !connecting && autoConnect) {
      let preferredWallet = localStorage.getItem(DEFAULT_STORAGE_KEY);
      if (typeof preferredWallet === "string") {
        select(preferredWallet);
      }
    }
  }, [wallet, connected, connecting, select, autoConnect]);
  const walletContext = useMemo(
    () => ({
      adapters,
      wallets,
      wallet,
      status,
      connecting,
      connected,
      isError,
      select,
      disconnect,
      async getAccounts() {
        if (wallet == null)
          throw Error("Wallet Not Connected");
        return wallet.getAccounts();
      },
      async signAndExecuteTransaction(transaction) {
        if (wallet == null) {
          throw new Error("Wallet Not Connected");
        }
        if (!wallet.signAndExecuteTransaction) {
          throw new Error(
            'Wallet does not support "signAndExecuteTransaction" method'
          );
        }
        return wallet.signAndExecuteTransaction(transaction);
      }
    }),
    [
      wallets,
      adapters,
      wallet,
      select,
      disconnect,
      connecting,
      connected,
      status,
      isError
    ]
  );
  return /* @__PURE__ */ jsx(WalletContext.Provider, {
    value: walletContext,
    children
  });
};
function useWallet() {
  const context = useContext(WalletContext);
  if (!context) {
    throw new Error(
      "You tried to access the `WalletContext` outside of the `WalletProvider`."
    );
  }
  return context;
}
export {
  WalletConnectionStatus,
  WalletContext,
  WalletProvider,
  useWallet
};
//# sourceMappingURL=index.mjs.map