{"ast":null,"code":"import { BcsType, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, lazyBcsType, stringLikeBcsType, uIntBcsType } from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      name: \"u8\",\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      name: \"u16\",\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      name: \"u32\",\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      name: \"u64\",\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      name: \"u128\",\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      name: \"u256\",\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      name: \"bool\",\n      size: 1,\n      read: reader => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      name: \"uleb128\",\n      read: reader => reader.readULEB(),\n      serialize: value => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      name: `bytes[${size}]`,\n      size,\n      read: reader => reader.readBytes(size),\n      write: (value, writer) => {\n        for (let i = 0; i < size; i++) {\n          writer.write8(value[i] ?? 0);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      name: \"string\",\n      toBytes: value => new TextEncoder().encode(value),\n      fromBytes: bytes => new TextDecoder().decode(bytes),\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray(size, type, options) {\n    return new BcsType({\n      name: `${type.name}[${size}]`,\n      read: reader => {\n        const result = new Array(size);\n        for (let i = 0; i < size; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option(type) {\n    return bcs.enum(`Option<${type.name}>`, {\n      None: null,\n      Some: type\n    }).transform({\n      input: value => {\n        if (value == null) {\n          return {\n            None: true\n          };\n        }\n        return {\n          Some: value\n        };\n      },\n      output: value => {\n        if (\"Some\" in value) {\n          return value.Some;\n        }\n        return null;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector(type, options) {\n    return new BcsType({\n      name: `vector<${type.name}>`,\n      read: reader => {\n        const length = reader.readULEB();\n        const result = new Array(length);\n        for (let i = 0; i < length; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        writer.writeULEB(value.length);\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(types, options) {\n    return new BcsType({\n      name: `(${types.map(t => t.name).join(\", \")})`,\n      serializedSize: values => {\n        let total = 0;\n        for (let i = 0; i < types.length; i++) {\n          const size = types[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = [];\n        for (const type of types) {\n          result.push(type.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < types.length; i++) {\n          types[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== types.length) {\n          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    const canonicalOrder = Object.entries(fields);\n    return new BcsType({\n      name,\n      serializedSize: values => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, values, options) {\n    const canonicalOrder = Object.entries(values);\n    return new BcsType({\n      name,\n      read: reader => {\n        const index = reader.readULEB();\n        const [name2, type] = canonicalOrder[index];\n        return {\n          [name2]: type?.read(reader) ?? true\n        };\n      },\n      write: (value, writer) => {\n        const [name2, val] = Object.entries(value)[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name2) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value);\n        if (keys.length !== 1) {\n          throw new TypeError(`Expected object with one key, found ${keys.length}`);\n        }\n        const [name2] = keys;\n        if (!Object.hasOwn(values, name2)) {\n          throw new TypeError(`Invalid enum variant ${name2}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map(keyType, valueType) {\n    return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n      name: `Map<${keyType.name}, ${valueType.name}>`,\n      input: value => {\n        return [...value.entries()];\n      },\n      output: value => {\n        const result = /* @__PURE__ */new Map();\n        for (const [key, val] of value) {\n          result.set(key, val);\n        }\n        return result;\n      }\n    });\n  },\n  /**\n   * @deprecated\n   *\n   * Generics should be implemented as generic typescript functions instead:\n   *\n   * ```ts\n   * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n   *   return bcs.struct('VecMap<K, V>', {\n   *     keys: bcs.vector(K),\n   *     values: bcs.vector(V),\n   *   })\n   * }\n   * ```\n   */\n  generic(_names, cb) {\n    return (...types) => {\n      return cb(...types).transform({\n        name: `${cb.name}<${types.map(t => t.name).join(\", \")}>`,\n        input: value => value,\n        output: value => value\n      });\n    };\n  },\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport { bcs };","map":{"version":3,"names":["BcsType","bigUIntBcsType","dynamicSizeBcsType","fixedSizeBcsType","lazyBcsType","stringLikeBcsType","uIntBcsType","ulebEncode","bcs","u8","options","name","readMethod","writeMethod","size","maxValue","u16","u32","u64","u128","u256","bool","read","reader","read8","write","value","writer","write8","validate","TypeError","uleb128","readULEB","serialize","Uint8Array","from","bytes","readBytes","i","length","string","toBytes","TextEncoder","encode","fromBytes","TextDecoder","decode","fixedArray","type","result","Array","item","option","enum","None","Some","transform","input","output","vector","writeULEB","tuple","types","map","t","join","serializedSize","values","total","push","isArray","struct","fields","canonicalOrder","Object","entries","field","index","name2","val","optionName","optionType","keys","hasOwn","keyType","valueType","Map","key","set","generic","_names","cb","lazy"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { GenericPlaceholder, ReplaceBcsGenerics } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif ('Some' in value) {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: true };\n\t\t\t\t}[keyof T],\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t\t}[keyof T]\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? { [K2 in K]: U } : { [K2 in K]: true };\n\t\t\t}[keyof T],\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t}[keyof T]\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\t\t\t\tconst [name, type] = canonicalOrder[index];\n\t\t\t\treturn {\n\t\t\t\t\t[name]: type?.read(reader) ?? true,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value)[0];\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(`Expected object with one key, found ${keys.length}`);\n\t\t\t\t}\n\n\t\t\t\tconst [name] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, name)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${name}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * @deprecated\n\t *\n\t * Generics should be implemented as generic typescript functions instead:\n\t *\n\t * ```ts\n\t * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n\t *   return bcs.struct('VecMap<K, V>', {\n\t *     keys: bcs.vector(K),\n\t *     values: bcs.vector(V),\n\t *   })\n\t * }\n\t * ```\n\t */\n\tgeneric<const Names extends readonly string[], const Type extends BcsType<any>>(\n\t\t_names: Names,\n\t\tcb: (...types: { [K in keyof Names]: BcsType<GenericPlaceholder<Names[K]>> }) => Type,\n\t): <T extends { [K in keyof Names]: BcsType<any> }>(\n\t\t...types: T\n\t) => ReplaceBcsGenerics<Type, Names, T> {\n\t\treturn (...types) => {\n\t\t\treturn cb(...types).transform({\n\t\t\t\tname: `${cb.name}<${types.map((t) => t.name).join(', ')}>`,\n\t\t\t\tinput: (value) => value,\n\t\t\t\toutput: (value) => value,\n\t\t\t}) as never;\n\t\t};\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}