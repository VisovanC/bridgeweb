{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _data, _client;\nimport { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport { PublicKey } from \"../cryptography/publickey.js\";\nimport { SIGNATURE_SCHEME_TO_FLAG } from \"../cryptography/signature-scheme.js\";\nimport { SuiGraphQLClient } from \"../graphql/client.js\";\nimport { graphql } from \"../graphql/schemas/2024.4/index.js\";\nimport { extractClaimValue } from \"./jwt-utils.js\";\nimport { parseZkLoginSignature } from \"./signature.js\";\nimport { toPaddedBigEndianBytes } from \"./utils.js\";\nconst _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier extends PublicKey {\n  /**\n   * Create a new ZkLoginPublicIdentifier object\n   * @param value zkLogin public identifier as buffer or base-64 encoded string\n   */\n  constructor(value, {\n    client\n  } = {}) {\n    super();\n    __privateAdd(this, _data);\n    __privateAdd(this, _client);\n    __privateSet(this, _client, client);\n    if (typeof value === \"string\") {\n      __privateSet(this, _data, fromBase64(value));\n    } else if (value instanceof Uint8Array) {\n      __privateSet(this, _data, value);\n    } else {\n      __privateSet(this, _data, Uint8Array.from(value));\n    }\n  }\n  /**\n   * Checks if two zkLogin public identifiers are equal\n   */\n  equals(publicKey) {\n    return super.equals(publicKey);\n  }\n  /**\n   * Return the byte array representation of the zkLogin public identifier\n   */\n  toRawBytes() {\n    return __privateGet(this, _data);\n  }\n  /**\n   * Return the Sui address associated with this ZkLogin public identifier\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"ZkLogin\"];\n  }\n  /**\n   * Verifies that the signature is valid for for the provided message\n   */\n  async verify(_message, _signature) {\n    throw Error(\"does not support\");\n  }\n  /**\n   * Verifies that the signature is valid for for the provided PersonalMessage\n   */\n  verifyPersonalMessage(message, signature) {\n    const parsedSignature = parseSerializedZkLoginSignature(signature);\n    const address = new _ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n    return graphqlVerifyZkLoginSignature({\n      address,\n      bytes: toBase64(message),\n      signature: parsedSignature.serializedSignature,\n      intentScope: \"PERSONAL_MESSAGE\",\n      client: __privateGet(this, _client)\n    });\n  }\n  /**\n   * Verifies that the signature is valid for for the provided Transaction\n   */\n  verifyTransaction(transaction, signature) {\n    const parsedSignature = parseSerializedZkLoginSignature(signature);\n    const address = new _ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n    return graphqlVerifyZkLoginSignature({\n      address,\n      bytes: toBase64(transaction),\n      signature: parsedSignature.serializedSignature,\n      intentScope: \"TRANSACTION_DATA\",\n      client: __privateGet(this, _client)\n    });\n  }\n};\n_data = new WeakMap();\n_client = new WeakMap();\nlet ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;\nfunction toZkLoginPublicIdentifier(addressSeed, iss, options) {\n  const addressSeedBytesBigEndian = toPaddedBigEndianBytes(addressSeed, 32);\n  const issBytes = new TextEncoder().encode(iss);\n  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n  tmp.set([issBytes.length], 0);\n  tmp.set(issBytes, 1);\n  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n  return new ZkLoginPublicIdentifier(tmp, options);\n}\nconst VerifyZkLoginSignatureQuery = graphql(`\n\tquery Zklogin(\n\t\t$bytes: Base64!\n\t\t$signature: Base64!\n\t\t$intentScope: ZkLoginIntentScope!\n\t\t$author: SuiAddress!\n\t) {\n\t\tverifyZkloginSignature(\n\t\t\tbytes: $bytes\n\t\t\tsignature: $signature\n\t\t\tintentScope: $intentScope\n\t\t\tauthor: $author\n\t\t) {\n\t\t\tsuccess\n\t\t\terrors\n\t\t}\n\t}\n`);\nasync function graphqlVerifyZkLoginSignature({\n  address,\n  bytes,\n  signature,\n  intentScope,\n  client = new SuiGraphQLClient({\n    url: \"https://sui-mainnet.mystenlabs.com/graphql\"\n  })\n}) {\n  const resp = await client.query({\n    query: VerifyZkLoginSignatureQuery,\n    variables: {\n      bytes,\n      signature,\n      intentScope,\n      author: address\n    }\n  });\n  return resp.data?.verifyZkloginSignature.success === true && resp.data?.verifyZkloginSignature.errors.length === 0;\n}\nfunction parseSerializedZkLoginSignature(signature) {\n  const bytes = typeof signature === \"string\" ? fromBase64(signature) : signature;\n  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n    throw new Error(\"Invalid signature scheme\");\n  }\n  const signatureBytes = bytes.slice(1);\n  const {\n    inputs,\n    maxEpoch,\n    userSignature\n  } = parseZkLoginSignature(signatureBytes);\n  const {\n    issBase64Details,\n    addressSeed\n  } = inputs;\n  const iss = extractClaimValue(issBase64Details, \"iss\");\n  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n  return {\n    serializedSignature: toBase64(bytes),\n    signatureScheme: \"ZkLogin\",\n    zkLogin: {\n      inputs,\n      maxEpoch,\n      userSignature,\n      iss,\n      addressSeed: BigInt(addressSeed)\n    },\n    signature: bytes,\n    publicKey: publicIdentifer.toRawBytes()\n  };\n}\nexport { ZkLoginPublicIdentifier, parseSerializedZkLoginSignature, toZkLoginPublicIdentifier };","map":{"version":3,"names":["_data","_client","fromBase64","toBase64","PublicKey","SIGNATURE_SCHEME_TO_FLAG","SuiGraphQLClient","graphql","extractClaimValue","parseZkLoginSignature","toPaddedBigEndianBytes","_ZkLoginPublicIdentifier","constructor","value","client","__privateAdd","__privateSet","Uint8Array","from","equals","publicKey","toRawBytes","__privateGet","flag","verify","_message","_signature","Error","verifyPersonalMessage","message","signature","parsedSignature","parseSerializedZkLoginSignature","address","toSuiAddress","graphqlVerifyZkLoginSignature","bytes","serializedSignature","intentScope","verifyTransaction","transaction","WeakMap","ZkLoginPublicIdentifier","toZkLoginPublicIdentifier","addressSeed","iss","options","addressSeedBytesBigEndian","issBytes","TextEncoder","encode","tmp","length","set","VerifyZkLoginSignatureQuery","url","resp","query","variables","author","data","verifyZkloginSignature","success","errors","ZkLogin","signatureBytes","slice","inputs","maxEpoch","userSignature","issBase64Details","publicIdentifer","BigInt","signatureScheme","zkLogin"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/src/zklogin/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\n\nimport { PublicKey } from '../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../cryptography/signature-scheme.js';\nimport { SuiGraphQLClient } from '../graphql/client.js';\nimport { graphql } from '../graphql/schemas/2024.4/index.js';\nimport { extractClaimValue } from './jwt-utils.js';\nimport { parseZkLoginSignature } from './signature.js';\nimport { toPaddedBigEndianBytes } from './utils.js';\n\n/**\n * A zkLogin public identifier\n */\nexport class ZkLoginPublicIdentifier extends PublicKey {\n\t#data: Uint8Array;\n\t#client?: SuiGraphQLClient;\n\n\t/**\n\t * Create a new ZkLoginPublicIdentifier object\n\t * @param value zkLogin public identifier as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData, { client }: { client?: SuiGraphQLClient } = {}) {\n\t\tsuper();\n\n\t\tthis.#client = client;\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.#data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.#data = value;\n\t\t} else {\n\t\t\tthis.#data = Uint8Array.from(value);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two zkLogin public identifiers are equal\n\t */\n\toverride equals(publicKey: ZkLoginPublicIdentifier): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the zkLogin public identifier\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this ZkLogin public identifier\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['ZkLogin'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(_message: Uint8Array, _signature: Uint8Array | string): Promise<boolean> {\n\t\tthrow Error('does not support');\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(message),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'PERSONAL_MESSAGE',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(transaction),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'TRANSACTION_DATA',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n}\n\n// Derive the public identifier for zklogin based on address seed and iss.\nexport function toZkLoginPublicIdentifier(\n\taddressSeed: bigint,\n\tiss: string,\n\toptions?: { client?: SuiGraphQLClient },\n): ZkLoginPublicIdentifier {\n\t// Consists of iss_bytes_len || iss_bytes || padded_32_byte_address_seed.\n\tconst addressSeedBytesBigEndian = toPaddedBigEndianBytes(addressSeed, 32);\n\tconst issBytes = new TextEncoder().encode(iss);\n\tconst tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n\ttmp.set([issBytes.length], 0);\n\ttmp.set(issBytes, 1);\n\ttmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n\treturn new ZkLoginPublicIdentifier(tmp, options);\n}\n\nconst VerifyZkLoginSignatureQuery = graphql(`\n\tquery Zklogin(\n\t\t$bytes: Base64!\n\t\t$signature: Base64!\n\t\t$intentScope: ZkLoginIntentScope!\n\t\t$author: SuiAddress!\n\t) {\n\t\tverifyZkloginSignature(\n\t\t\tbytes: $bytes\n\t\t\tsignature: $signature\n\t\t\tintentScope: $intentScope\n\t\t\tauthor: $author\n\t\t) {\n\t\t\tsuccess\n\t\t\terrors\n\t\t}\n\t}\n`);\n\nasync function graphqlVerifyZkLoginSignature({\n\taddress,\n\tbytes,\n\tsignature,\n\tintentScope,\n\tclient = new SuiGraphQLClient({\n\t\turl: 'https://sui-mainnet.mystenlabs.com/graphql',\n\t}),\n}: {\n\taddress: string;\n\tbytes: string;\n\tsignature: string;\n\tintentScope: 'PERSONAL_MESSAGE' | 'TRANSACTION_DATA';\n\tclient?: SuiGraphQLClient;\n}) {\n\tconst resp = await client.query({\n\t\tquery: VerifyZkLoginSignatureQuery,\n\t\tvariables: {\n\t\t\tbytes,\n\t\t\tsignature,\n\t\t\tintentScope,\n\t\t\tauthor: address,\n\t\t},\n\t});\n\n\treturn (\n\t\tresp.data?.verifyZkloginSignature.success === true &&\n\t\tresp.data?.verifyZkloginSignature.errors.length === 0\n\t);\n}\n\nexport function parseSerializedZkLoginSignature(signature: Uint8Array | string) {\n\tconst bytes = typeof signature === 'string' ? fromBase64(signature) : signature;\n\n\tif (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n\t\tthrow new Error('Invalid signature scheme');\n\t}\n\n\tconst signatureBytes = bytes.slice(1);\n\tconst { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);\n\tconst { issBase64Details, addressSeed } = inputs;\n\tconst iss = extractClaimValue<string>(issBase64Details, 'iss');\n\tconst publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n\treturn {\n\t\tserializedSignature: toBase64(bytes),\n\t\tsignatureScheme: 'ZkLogin' as const,\n\t\tzkLogin: {\n\t\t\tinputs,\n\t\t\tmaxEpoch,\n\t\t\tuserSignature,\n\t\t\tiss,\n\t\t\taddressSeed: BigInt(addressSeed),\n\t\t},\n\t\tsignature: bytes,\n\t\tpublicKey: publicIdentifer.toRawBytes(),\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}