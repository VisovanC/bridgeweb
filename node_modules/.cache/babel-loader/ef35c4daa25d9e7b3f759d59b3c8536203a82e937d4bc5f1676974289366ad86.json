{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _write, _serialize, _schema, _bytes;\nimport { toB58 } from \"./b58.js\";\nimport { toB64 } from \"./b64.js\";\nimport { toHEX } from \"./hex.js\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class {\n  constructor(options) {\n    __privateAdd(this, _write, void 0);\n    __privateAdd(this, _serialize, void 0);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({\n        size: this.serializedSize(value) ?? void 0,\n        ...options2\n      });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {});\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  transform({\n    name,\n    input,\n    output\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: reader => output(this.read(reader)),\n      write: (value, writer) => __privateGet(this, _write).call(this, input(value), writer),\n      serializedSize: value => this.serializedSize(input(value)),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input(value), options),\n      validate: value => this.validate(input(value))\n    });\n  }\n};\nlet BcsType = _BcsType;\n_write = new WeakMap();\n_serialize = new WeakMap();\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(type, schema) {\n    __privateAdd(this, _schema, void 0);\n    __privateAdd(this, _bytes, void 0);\n    __privateSet(this, _schema, type);\n    __privateSet(this, _bytes, schema);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHEX(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toB64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toB58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: value => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: val => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: reader => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: value => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: value => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: data => getType().read(data),\n    serializedSize: value => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nexport { BcsType, SerializedBcs, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, isSerializedBcs, lazyBcsType, stringLikeBcsType, uIntBcsType };","map":{"version":3,"names":["_write","_serialize","_schema","_bytes","toB58","toB64","toHEX","BcsReader","ulebEncode","BcsWriter","_BcsType","constructor","options","__privateAdd","name","read","serializedSize","__privateSet","write","serialize","value","options2","writer","size","__privateGet","call","toBytes","validate","SerializedBcs","parse","bytes","reader","transform","input","output","BcsType","WeakMap","SERIALIZED_BCS_BRAND","Symbol","for","isSerializedBcs","obj","type","schema","toHex","toBase64","toBase58","fixedSizeBcsType","uIntBcsType","readMethod","writeMethod","maxValue","TypeError","bigUIntBcsType","BigInt","val","dynamicSizeBcsType","byte","write8","stringLikeBcsType","fromBytes","length","readULEB","readBytes","hex","writeULEB","i","result","Uint8Array","set","lazyBcsType","cb","lazyType","getType","data"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from './b58.js';\nimport { toB64 } from './b64.js';\nimport { toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => this.validate(input(value)),\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}