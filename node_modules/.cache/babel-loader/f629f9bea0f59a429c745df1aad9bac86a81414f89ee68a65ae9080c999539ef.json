{"ast":null,"code":"import { BcsType, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, lazyBcsType, stringLikeBcsType, uIntBcsType } from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      name: \"u8\",\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      name: \"u16\",\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      name: \"u32\",\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      name: \"u64\",\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      name: \"u128\",\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      name: \"u256\",\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      name: \"bool\",\n      size: 1,\n      read: reader => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      name: \"uleb128\",\n      read: reader => reader.readULEB(),\n      serialize: value => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      name: `bytes[${size}]`,\n      size,\n      read: reader => reader.readBytes(size),\n      write: (value, writer) => {\n        for (let i = 0; i < size; i++) {\n          writer.write8(value[i] ?? 0);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      name: \"string\",\n      toBytes: value => new TextEncoder().encode(value),\n      fromBytes: bytes => new TextDecoder().decode(bytes),\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray(size, type, options) {\n    return new BcsType({\n      name: `${type.name}[${size}]`,\n      read: reader => {\n        const result = new Array(size);\n        for (let i = 0; i < size; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option(type) {\n    return bcs.enum(`Option<${type.name}>`, {\n      None: null,\n      Some: type\n    }).transform({\n      input: value => {\n        if (value == null) {\n          return {\n            None: true\n          };\n        }\n        return {\n          Some: value\n        };\n      },\n      output: value => {\n        if (value.$kind === \"Some\") {\n          return value.Some;\n        }\n        return null;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector(type, options) {\n    return new BcsType({\n      name: `vector<${type.name}>`,\n      read: reader => {\n        const length = reader.readULEB();\n        const result = new Array(length);\n        for (let i = 0; i < length; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        writer.writeULEB(value.length);\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(types, options) {\n    return new BcsType({\n      name: `(${types.map(t => t.name).join(\", \")})`,\n      serializedSize: values => {\n        let total = 0;\n        for (let i = 0; i < types.length; i++) {\n          const size = types[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = [];\n        for (const type of types) {\n          result.push(type.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < types.length; i++) {\n          types[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== types.length) {\n          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    const canonicalOrder = Object.entries(fields);\n    return new BcsType({\n      name,\n      serializedSize: values => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, values, options) {\n    const canonicalOrder = Object.entries(values);\n    return new BcsType({\n      name,\n      read: reader => {\n        const index = reader.readULEB();\n        const enumEntry = canonicalOrder[index];\n        if (!enumEntry) {\n          throw new TypeError(`Unknown value ${index} for enum ${name}`);\n        }\n        const [kind, type] = enumEntry;\n        return {\n          [kind]: type?.read(reader) ?? true,\n          $kind: kind\n        };\n      },\n      write: (value, writer) => {\n        const [name2, val] = Object.entries(value).filter(([name3]) => Object.hasOwn(values, name3))[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name2) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value).filter(k => value[k] !== void 0 && Object.hasOwn(values, k));\n        if (keys.length !== 1) {\n          throw new TypeError(`Expected object with one key, but found ${keys.length} for type ${name}}`);\n        }\n        const [variant] = keys;\n        if (!Object.hasOwn(values, variant)) {\n          throw new TypeError(`Invalid enum variant ${variant}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map(keyType, valueType) {\n    return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n      name: `Map<${keyType.name}, ${valueType.name}>`,\n      input: value => {\n        return [...value.entries()];\n      },\n      output: value => {\n        const result = /* @__PURE__ */new Map();\n        for (const [key, val] of value) {\n          result.set(key, val);\n        }\n        return result;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport { bcs };","map":{"version":3,"names":["BcsType","bigUIntBcsType","dynamicSizeBcsType","fixedSizeBcsType","lazyBcsType","stringLikeBcsType","uIntBcsType","ulebEncode","bcs","u8","options","name","readMethod","writeMethod","size","maxValue","u16","u32","u64","u128","u256","bool","read","reader","read8","write","value","writer","write8","validate","TypeError","uleb128","readULEB","serialize","Uint8Array","from","bytes","readBytes","i","length","string","toBytes","TextEncoder","encode","fromBytes","TextDecoder","decode","fixedArray","type","result","Array","item","option","enum","None","Some","transform","input","output","$kind","vector","writeULEB","tuple","types","map","t","join","serializedSize","values","total","push","isArray","struct","fields","canonicalOrder","Object","entries","field","index","enumEntry","kind","name2","val","filter","name3","hasOwn","optionName","optionType","keys","k","variant","keyType","valueType","Map","key","set","lazy","cb"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}