{"ast":null,"code":"import { isSerializedBcs } from \"@mysten/bcs\";\nimport { bcs } from \"../bcs/index.js\";\nfunction createPure(makePure) {\n  function pure(typeOrSerializedValue, value) {\n    if (typeof typeOrSerializedValue === \"string\") {\n      return makePure(schemaFromName(typeOrSerializedValue).serialize(value));\n    }\n    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n      return makePure(typeOrSerializedValue);\n    }\n    throw new Error(\"tx.pure must be called either a bcs type name, or a serialized bcs value\");\n  }\n  pure.u8 = value => makePure(bcs.U8.serialize(value));\n  pure.u16 = value => makePure(bcs.U16.serialize(value));\n  pure.u32 = value => makePure(bcs.U32.serialize(value));\n  pure.u64 = value => makePure(bcs.U64.serialize(value));\n  pure.u128 = value => makePure(bcs.U128.serialize(value));\n  pure.u256 = value => makePure(bcs.U256.serialize(value));\n  pure.bool = value => makePure(bcs.Bool.serialize(value));\n  pure.string = value => makePure(bcs.String.serialize(value));\n  pure.address = value => makePure(bcs.Address.serialize(value));\n  pure.id = pure.address;\n  pure.vector = (type, value) => {\n    return makePure(bcs.vector(schemaFromName(type)).serialize(value));\n  };\n  pure.option = (type, value) => {\n    return makePure(bcs.option(schemaFromName(type)).serialize(value));\n  };\n  return pure;\n}\nfunction schemaFromName(name) {\n  switch (name) {\n    case \"u8\":\n      return bcs.u8();\n    case \"u16\":\n      return bcs.u16();\n    case \"u32\":\n      return bcs.u32();\n    case \"u64\":\n      return bcs.u64();\n    case \"u128\":\n      return bcs.u128();\n    case \"u256\":\n      return bcs.u256();\n    case \"bool\":\n      return bcs.bool();\n    case \"string\":\n      return bcs.string();\n    case \"id\":\n    case \"address\":\n      return bcs.Address;\n  }\n  const generic = name.match(/^(vector|option)<(.+)>$/);\n  if (generic) {\n    const [kind, inner] = generic.slice(1);\n    if (kind === \"vector\") {\n      return bcs.vector(schemaFromName(inner));\n    } else {\n      return bcs.option(schemaFromName(inner));\n    }\n  }\n  throw new Error(`Invalid Pure type name: ${name}`);\n}\nexport { createPure };","map":{"version":3,"names":["isSerializedBcs","bcs","createPure","makePure","pure","typeOrSerializedValue","value","schemaFromName","serialize","Uint8Array","Error","u8","U8","u16","U16","u32","U32","u64","U64","u128","U128","u256","U256","bool","Bool","string","String","address","Address","id","vector","type","option","name","generic","match","kind","inner","slice"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/src/transactions/pure.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { BcsType, SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Argument } from './data/internal.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<T extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<T> : T,\n\t\tvalue: ShapeFromPureTypeName<T>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(schemaFromName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(bcs.vector(schemaFromName(type as BasePureType)).serialize(value as never));\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(schemaFromName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\ntype ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? Parameters<ReturnType<typeof createPure<Argument>>[T]>[0]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = T & {\n\terror: `Invalid Pure type name: ${T}`;\n};\n\nfunction schemaFromName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn bcs.Address as never;\n\t}\n\n\tconst generic = name.match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(schemaFromName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(schemaFromName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}