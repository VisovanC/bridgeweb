{"ast":null,"code":"import { fromBase64 } from \"@mysten/bcs\";\nimport { parseSerializedSignature, SIGNATURE_FLAG_TO_SCHEME } from \"../cryptography/index.js\";\nimport { Ed25519PublicKey } from \"../keypairs/ed25519/publickey.js\";\nimport { Secp256k1PublicKey } from \"../keypairs/secp256k1/publickey.js\";\nimport { Secp256r1PublicKey } from \"../keypairs/secp256r1/publickey.js\";\nimport { MultiSigPublicKey } from \"../multisig/publickey.js\";\nimport { ZkLoginPublicIdentifier } from \"../zklogin/publickey.js\";\nasync function verifySignature(bytes, signature) {\n  const parsedSignature = parseSignature(signature);\n  if (!(await parsedSignature.publicKey.verify(bytes, parsedSignature.serializedSignature))) {\n    throw new Error(`Signature is not valid for the provided data`);\n  }\n  return parsedSignature.publicKey;\n}\nasync function verifyPersonalMessageSignature(message, signature, options = {}) {\n  const parsedSignature = parseSignature(signature, options);\n  if (!(await parsedSignature.publicKey.verifyPersonalMessage(message, parsedSignature.serializedSignature))) {\n    throw new Error(`Signature is not valid for the provided message`);\n  }\n  return parsedSignature.publicKey;\n}\nasync function verifyTransactionSignature(transaction, signature, options = {}) {\n  const parsedSignature = parseSignature(signature, options);\n  if (!(await parsedSignature.publicKey.verifyTransaction(transaction, parsedSignature.serializedSignature))) {\n    throw new Error(`Signature is not valid for the provided Transaction`);\n  }\n  return parsedSignature.publicKey;\n}\nfunction parseSignature(signature, options = {}) {\n  const parsedSignature = parseSerializedSignature(signature);\n  if (parsedSignature.signatureScheme === \"MultiSig\") {\n    return {\n      ...parsedSignature,\n      publicKey: new MultiSigPublicKey(parsedSignature.multisig.multisig_pk)\n    };\n  }\n  const publicKey = publicKeyFromRawBytes(parsedSignature.signatureScheme, parsedSignature.publicKey, options);\n  return {\n    ...parsedSignature,\n    publicKey\n  };\n}\nfunction publicKeyFromRawBytes(signatureScheme, bytes, options = {}) {\n  switch (signatureScheme) {\n    case \"ED25519\":\n      return new Ed25519PublicKey(bytes);\n    case \"Secp256k1\":\n      return new Secp256k1PublicKey(bytes);\n    case \"Secp256r1\":\n      return new Secp256r1PublicKey(bytes);\n    case \"MultiSig\":\n      return new MultiSigPublicKey(bytes);\n    case \"ZkLogin\":\n      return new ZkLoginPublicIdentifier(bytes, options);\n    default:\n      throw new Error(`Unsupported signature scheme ${signatureScheme}`);\n  }\n}\nfunction publicKeyFromSuiBytes(publicKey, options = {}) {\n  const bytes = typeof publicKey === \"string\" ? fromBase64(publicKey) : publicKey;\n  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];\n  return publicKeyFromRawBytes(signatureScheme, bytes.slice(1), options);\n}\nexport { publicKeyFromRawBytes, publicKeyFromSuiBytes, verifyPersonalMessageSignature, verifySignature, verifyTransactionSignature };","map":{"version":3,"names":["fromBase64","parseSerializedSignature","SIGNATURE_FLAG_TO_SCHEME","Ed25519PublicKey","Secp256k1PublicKey","Secp256r1PublicKey","MultiSigPublicKey","ZkLoginPublicIdentifier","verifySignature","bytes","signature","parsedSignature","parseSignature","publicKey","verify","serializedSignature","Error","verifyPersonalMessageSignature","message","options","verifyPersonalMessage","verifyTransactionSignature","transaction","verifyTransaction","signatureScheme","multisig","multisig_pk","publicKeyFromRawBytes","publicKeyFromSuiBytes","slice"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/src/verify/verify.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\n\nimport type { PublicKey, SignatureFlag, SignatureScheme } from '../cryptography/index.js';\nimport { parseSerializedSignature, SIGNATURE_FLAG_TO_SCHEME } from '../cryptography/index.js';\nimport type { SuiGraphQLClient } from '../graphql/client.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\n// eslint-disable-next-line import/no-cycle\nimport { MultiSigPublicKey } from '../multisig/publickey.js';\nimport { ZkLoginPublicIdentifier } from '../zklogin/publickey.js';\n\nexport async function verifySignature(bytes: Uint8Array, signature: string): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature);\n\n\tif (!(await parsedSignature.publicKey.verify(bytes, parsedSignature.serializedSignature))) {\n\t\tthrow new Error(`Signature is not valid for the provided data`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyPersonalMessageSignature(\n\tmessage: Uint8Array,\n\tsignature: string,\n\toptions: { client?: SuiGraphQLClient } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyPersonalMessage(\n\t\t\tmessage,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided message`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyTransactionSignature(\n\ttransaction: Uint8Array,\n\tsignature: string,\n\toptions: { client?: SuiGraphQLClient } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyTransaction(\n\t\t\ttransaction,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided Transaction`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nfunction parseSignature(signature: string, options: { client?: SuiGraphQLClient } = {}) {\n\tconst parsedSignature = parseSerializedSignature(signature);\n\n\tif (parsedSignature.signatureScheme === 'MultiSig') {\n\t\treturn {\n\t\t\t...parsedSignature,\n\t\t\tpublicKey: new MultiSigPublicKey(parsedSignature.multisig.multisig_pk),\n\t\t};\n\t}\n\n\tconst publicKey = publicKeyFromRawBytes(\n\t\tparsedSignature.signatureScheme,\n\t\tparsedSignature.publicKey,\n\t\toptions,\n\t);\n\treturn {\n\t\t...parsedSignature,\n\t\tpublicKey,\n\t};\n}\n\nexport function publicKeyFromRawBytes(\n\tsignatureScheme: SignatureScheme,\n\tbytes: Uint8Array,\n\toptions: { client?: SuiGraphQLClient } = {},\n): PublicKey {\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\t\treturn new Ed25519PublicKey(bytes);\n\t\tcase 'Secp256k1':\n\t\t\treturn new Secp256k1PublicKey(bytes);\n\t\tcase 'Secp256r1':\n\t\t\treturn new Secp256r1PublicKey(bytes);\n\t\tcase 'MultiSig':\n\t\t\treturn new MultiSigPublicKey(bytes);\n\t\tcase 'ZkLogin':\n\t\t\treturn new ZkLoginPublicIdentifier(bytes, options);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported signature scheme ${signatureScheme}`);\n\t}\n}\n\nexport function publicKeyFromSuiBytes(\n\tpublicKey: string | Uint8Array,\n\toptions: { client?: SuiGraphQLClient } = {},\n) {\n\tconst bytes = typeof publicKey === 'string' ? fromBase64(publicKey) : publicKey;\n\n\tconst signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0] as SignatureFlag];\n\n\treturn publicKeyFromRawBytes(signatureScheme, bytes.slice(1), options);\n}\n"],"mappings":"AAGA,SAASA,UAAA,QAAkB;AAG3B,SAASC,wBAAA,EAA0BC,wBAAA,QAAgC;AAEnE,SAASC,gBAAA,QAAwB;AACjC,SAASC,kBAAA,QAA0B;AACnC,SAASC,kBAAA,QAA0B;AAEnC,SAASC,iBAAA,QAAyB;AAClC,SAASC,uBAAA,QAA+B;AAExC,eAAsBC,gBAAgBC,KAAA,EAAmBC,SAAA,EAAuC;EAC/F,MAAMC,eAAA,GAAkBC,cAAA,CAAeF,SAAS;EAEhD,IAAI,EAAE,MAAMC,eAAA,CAAgBE,SAAA,CAAUC,MAAA,CAAOL,KAAA,EAAOE,eAAA,CAAgBI,mBAAmB,IAAI;IAC1F,MAAM,IAAIC,KAAA,CAAM,8CAA8C;EAC/D;EAEA,OAAOL,eAAA,CAAgBE,SAAA;AACxB;AAEA,eAAsBI,+BACrBC,OAAA,EACAR,SAAA,EACAS,OAAA,GAAyC,CAAC,GACrB;EACrB,MAAMR,eAAA,GAAkBC,cAAA,CAAeF,SAAA,EAAWS,OAAO;EAEzD,IACC,EAAE,MAAMR,eAAA,CAAgBE,SAAA,CAAUO,qBAAA,CACjCF,OAAA,EACAP,eAAA,CAAgBI,mBACjB,IACC;IACD,MAAM,IAAIC,KAAA,CAAM,iDAAiD;EAClE;EAEA,OAAOL,eAAA,CAAgBE,SAAA;AACxB;AAEA,eAAsBQ,2BACrBC,WAAA,EACAZ,SAAA,EACAS,OAAA,GAAyC,CAAC,GACrB;EACrB,MAAMR,eAAA,GAAkBC,cAAA,CAAeF,SAAA,EAAWS,OAAO;EAEzD,IACC,EAAE,MAAMR,eAAA,CAAgBE,SAAA,CAAUU,iBAAA,CACjCD,WAAA,EACAX,eAAA,CAAgBI,mBACjB,IACC;IACD,MAAM,IAAIC,KAAA,CAAM,qDAAqD;EACtE;EAEA,OAAOL,eAAA,CAAgBE,SAAA;AACxB;AAEA,SAASD,eAAeF,SAAA,EAAmBS,OAAA,GAAyC,CAAC,GAAG;EACvF,MAAMR,eAAA,GAAkBV,wBAAA,CAAyBS,SAAS;EAE1D,IAAIC,eAAA,CAAgBa,eAAA,KAAoB,YAAY;IACnD,OAAO;MACN,GAAGb,eAAA;MACHE,SAAA,EAAW,IAAIP,iBAAA,CAAkBK,eAAA,CAAgBc,QAAA,CAASC,WAAW;IACtE;EACD;EAEA,MAAMb,SAAA,GAAYc,qBAAA,CACjBhB,eAAA,CAAgBa,eAAA,EAChBb,eAAA,CAAgBE,SAAA,EAChBM,OACD;EACA,OAAO;IACN,GAAGR,eAAA;IACHE;EACD;AACD;AAEO,SAASc,sBACfH,eAAA,EACAf,KAAA,EACAU,OAAA,GAAyC,CAAC,GAC9B;EACZ,QAAQK,eAAA;IACP,KAAK;MACJ,OAAO,IAAIrB,gBAAA,CAAiBM,KAAK;IAClC,KAAK;MACJ,OAAO,IAAIL,kBAAA,CAAmBK,KAAK;IACpC,KAAK;MACJ,OAAO,IAAIJ,kBAAA,CAAmBI,KAAK;IACpC,KAAK;MACJ,OAAO,IAAIH,iBAAA,CAAkBG,KAAK;IACnC,KAAK;MACJ,OAAO,IAAIF,uBAAA,CAAwBE,KAAA,EAAOU,OAAO;IAClD;MACC,MAAM,IAAIH,KAAA,CAAM,gCAAgCQ,eAAe,EAAE;EACnE;AACD;AAEO,SAASI,sBACff,SAAA,EACAM,OAAA,GAAyC,CAAC,GACzC;EACD,MAAMV,KAAA,GAAQ,OAAOI,SAAA,KAAc,WAAWb,UAAA,CAAWa,SAAS,IAAIA,SAAA;EAEtE,MAAMW,eAAA,GAAkBtB,wBAAA,CAAyBO,KAAA,CAAM,CAAC,CAAkB;EAE1E,OAAOkB,qBAAA,CAAsBH,eAAA,EAAiBf,KAAA,CAAMoB,KAAA,CAAM,CAAC,GAAGV,OAAO;AACtE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}