{"ast":null,"code":"import { bigint, object, parse, string } from \"valibot\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { normalizeStructTag } from \"../../utils/sui-types.js\";\nimport { Commands } from \"../Commands.js\";\nimport { Inputs } from \"../Inputs.js\";\nimport { getClient } from \"../json-rpc-resolver.js\";\nconst COIN_WITH_BALANCE = \"CoinWithBalance\";\nconst SUI_TYPE = normalizeStructTag(\"0x2::sui::SUI\");\nfunction coinWithBalance({\n  type = SUI_TYPE,\n  balance,\n  useGasCoin = true\n}) {\n  return tx => {\n    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n    const coinType = type === \"gas\" ? type : normalizeStructTag(type);\n    return tx.add(Commands.Intent({\n      name: COIN_WITH_BALANCE,\n      inputs: {},\n      data: {\n        type: coinType === SUI_TYPE && useGasCoin ? \"gas\" : coinType,\n        balance: BigInt(balance)\n      }\n    }));\n  };\n}\nconst CoinWithBalanceData = object({\n  type: string(),\n  balance: bigint()\n});\nasync function resolveCoinBalance(transactionData, buildOptions, next) {\n  const coinTypes = /* @__PURE__ */new Set();\n  const totalByType = /* @__PURE__ */new Map();\n  if (!transactionData.sender) {\n    throw new Error(\"Sender must be set to resolve CoinWithBalance\");\n  }\n  for (const command of transactionData.commands) {\n    if (command.$kind === \"$Intent\" && command.$Intent.name === COIN_WITH_BALANCE) {\n      const {\n        type,\n        balance\n      } = parse(CoinWithBalanceData, command.$Intent.data);\n      if (type !== \"gas\") {\n        coinTypes.add(type);\n      }\n      totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n    }\n  }\n  const usedIds = /* @__PURE__ */new Set();\n  for (const input of transactionData.inputs) {\n    if (input.Object?.ImmOrOwnedObject) {\n      usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n    }\n    if (input.UnresolvedObject?.objectId) {\n      usedIds.add(input.UnresolvedObject.objectId);\n    }\n  }\n  const coinsByType = /* @__PURE__ */new Map();\n  const client = getClient(buildOptions);\n  await Promise.all([...coinTypes].map(async coinType => {\n    coinsByType.set(coinType, await getCoinsOfType({\n      coinType,\n      balance: totalByType.get(coinType),\n      client,\n      owner: transactionData.sender,\n      usedIds\n    }));\n  }));\n  const mergedCoins = /* @__PURE__ */new Map();\n  mergedCoins.set(\"gas\", {\n    $kind: \"GasCoin\",\n    GasCoin: true\n  });\n  for (const [index, transaction] of transactionData.commands.entries()) {\n    if (transaction.$kind !== \"$Intent\" || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n      continue;\n    }\n    const {\n      type,\n      balance\n    } = transaction.$Intent.data;\n    const commands = [];\n    if (!mergedCoins.has(type)) {\n      const [first, ...rest] = coinsByType.get(type).map(coin => transactionData.addInput(\"object\", Inputs.ObjectRef({\n        objectId: coin.coinObjectId,\n        digest: coin.digest,\n        version: coin.version\n      })));\n      if (rest.length > 0) {\n        commands.push(Commands.MergeCoins(first, rest));\n      }\n      mergedCoins.set(type, first);\n    }\n    commands.push(Commands.SplitCoins(mergedCoins.get(type), [transactionData.addInput(\"pure\", Inputs.Pure(bcs.u64().serialize(balance)))]));\n    transactionData.replaceCommand(index, commands);\n    transactionData.mapArguments(arg => {\n      if (arg.$kind === \"Result\" && arg.Result === index) {\n        return {\n          $kind: \"NestedResult\",\n          NestedResult: [index + commands.length - 1, 0]\n        };\n      }\n      return arg;\n    });\n  }\n  return next();\n}\nasync function getCoinsOfType({\n  coinType,\n  balance,\n  client,\n  owner,\n  usedIds\n}) {\n  let remainingBalance = balance;\n  const coins = [];\n  return loadMoreCoins();\n  async function loadMoreCoins(cursor = null) {\n    const {\n      data,\n      hasNextPage,\n      nextCursor\n    } = await client.getCoins({\n      owner,\n      coinType,\n      cursor\n    });\n    const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n    for (const coin of sortedCoins) {\n      if (usedIds.has(coin.coinObjectId)) {\n        continue;\n      }\n      const coinBalance = BigInt(coin.balance);\n      coins.push(coin);\n      remainingBalance -= coinBalance;\n      if (remainingBalance <= 0) {\n        return coins;\n      }\n    }\n    if (hasNextPage) {\n      return loadMoreCoins(nextCursor);\n    }\n    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n  }\n}\nexport { coinWithBalance };","map":{"version":3,"names":["bigint","object","parse","string","bcs","normalizeStructTag","Commands","Inputs","getClient","COIN_WITH_BALANCE","SUI_TYPE","coinWithBalance","type","balance","useGasCoin","tx","addIntentResolver","resolveCoinBalance","coinType","add","Intent","name","inputs","data","BigInt","CoinWithBalanceData","transactionData","buildOptions","next","coinTypes","Set","totalByType","Map","sender","Error","command","commands","$kind","$Intent","set","get","usedIds","input","Object","ImmOrOwnedObject","objectId","UnresolvedObject","coinsByType","client","Promise","all","map","getCoinsOfType","owner","mergedCoins","GasCoin","index","transaction","entries","has","first","rest","coin","addInput","ObjectRef","coinObjectId","digest","version","length","push","MergeCoins","SplitCoins","Pure","u64","serialize","replaceCommand","mapArguments","arg","Result","NestedResult","remainingBalance","coins","loadMoreCoins","cursor","hasNextPage","nextCursor","getCoins","sortedCoins","sort","a","b","Number","coinBalance"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/src/transactions/intents/CoinWithBalance.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, SuiClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/sui-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport { getClient } from '../json-rpc-resolver.js';\nimport type { Transaction } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst SUI_TYPE = normalizeStructTag('0x2::sui::SUI');\n\nexport function coinWithBalance({\n\ttype = SUI_TYPE,\n\tbalance,\n\tuseGasCoin = true,\n}: {\n\tbalance: bigint | number;\n\ttype?: string;\n\tuseGasCoin?: boolean;\n}) {\n\treturn (tx: Transaction) => {\n\t\ttx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n\t\tconst coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n\t\treturn tx.add(\n\t\t\tCommands.Intent({\n\t\t\t\tname: COIN_WITH_BALANCE,\n\t\t\t\tinputs: {},\n\t\t\t\tdata: {\n\t\t\t\t\ttype: coinType === SUI_TYPE && useGasCoin ? 'gas' : coinType,\n\t\t\t\t\tbalance: BigInt(balance),\n\t\t\t\t} satisfies InferInput<typeof CoinWithBalanceData>,\n\t\t\t}),\n\t\t);\n\t};\n}\n\nconst CoinWithBalanceData = object({\n\ttype: string(),\n\tbalance: bigint(),\n});\n\nasync function resolveCoinBalance(\n\ttransactionData: TransactionDataBuilder,\n\tbuildOptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tconst coinTypes = new Set<string>();\n\tconst totalByType = new Map<string, bigint>();\n\n\tif (!transactionData.sender) {\n\t\tthrow new Error('Sender must be set to resolve CoinWithBalance');\n\t}\n\n\tfor (const command of transactionData.commands) {\n\t\tif (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n\t\t\tconst { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n\t\t\tif (type !== 'gas') {\n\t\t\t\tcoinTypes.add(type);\n\t\t\t}\n\n\t\t\ttotalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n\t\t}\n\t}\n\tconst usedIds = new Set<string>();\n\n\tfor (const input of transactionData.inputs) {\n\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\tusedIds.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\t\tif (input.UnresolvedObject?.objectId) {\n\t\t\tusedIds.add(input.UnresolvedObject.objectId);\n\t\t}\n\t}\n\n\tconst coinsByType = new Map<string, CoinStruct[]>();\n\tconst client = getClient(buildOptions);\n\tawait Promise.all(\n\t\t[...coinTypes].map(async (coinType) => {\n\t\t\tcoinsByType.set(\n\t\t\t\tcoinType,\n\t\t\t\tawait getCoinsOfType({\n\t\t\t\t\tcoinType,\n\t\t\t\t\tbalance: totalByType.get(coinType)!,\n\t\t\t\t\tclient,\n\t\t\t\t\towner: transactionData.sender!,\n\t\t\t\t\tusedIds,\n\t\t\t\t}),\n\t\t\t);\n\t\t}),\n\t);\n\n\tconst mergedCoins = new Map<string, Argument>();\n\n\tmergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n\tfor (const [index, transaction] of transactionData.commands.entries()) {\n\t\tif (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { type, balance } = transaction.$Intent.data as {\n\t\t\ttype: string;\n\t\t\tbalance: bigint;\n\t\t};\n\n\t\tconst commands = [];\n\n\t\tif (!mergedCoins.has(type)) {\n\t\t\tconst [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n\t\t\t\ttransactionData.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\tInputs.ObjectRef({\n\t\t\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\t\tversion: coin.version,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tif (rest.length > 0) {\n\t\t\t\tcommands.push(Commands.MergeCoins(first, rest));\n\t\t\t}\n\n\t\t\tmergedCoins.set(type, first);\n\t\t}\n\n\t\tcommands.push(\n\t\t\tCommands.SplitCoins(mergedCoins.get(type)!, [\n\t\t\t\ttransactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n\t\t\t]),\n\t\t);\n\n\t\ttransactionData.replaceCommand(index, commands);\n\n\t\ttransactionData.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Result' && arg.Result === index) {\n\t\t\t\treturn {\n\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\tNestedResult: [index + commands.length - 1, 0],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treturn next();\n}\n\nasync function getCoinsOfType({\n\tcoinType,\n\tbalance,\n\tclient,\n\towner,\n\tusedIds,\n}: {\n\tcoinType: string;\n\tbalance: bigint;\n\tclient: SuiClient;\n\towner: string;\n\tusedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n\tlet remainingBalance = balance;\n\tconst coins: CoinStruct[] = [];\n\n\treturn loadMoreCoins();\n\n\tasync function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n\t\tconst { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n\n\t\tconst sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n\t\tfor (const coin of sortedCoins) {\n\t\t\tif (usedIds.has(coin.coinObjectId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst coinBalance = BigInt(coin.balance);\n\n\t\t\tcoins.push(coin);\n\t\t\tremainingBalance -= coinBalance;\n\n\t\t\tif (remainingBalance <= 0) {\n\t\t\t\treturn coins;\n\t\t\t}\n\t\t}\n\n\t\tif (hasNextPage) {\n\t\t\treturn loadMoreCoins(nextCursor);\n\t\t}\n\n\t\tthrow new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n\t}\n}\n"],"mappings":"AAIA,SAASA,MAAA,EAAQC,MAAA,EAAQC,KAAA,EAAOC,MAAA,QAAc;AAE9C,SAASC,GAAA,QAAW;AAEpB,SAASC,kBAAA,QAA0B;AACnC,SAASC,QAAA,QAAgB;AAEzB,SAASC,MAAA,QAAc;AAEvB,SAASC,SAAA,QAAiB;AAI1B,MAAMC,iBAAA,GAAoB;AAC1B,MAAMC,QAAA,GAAWL,kBAAA,CAAmB,eAAe;AAE5C,SAASM,gBAAgB;EAC/BC,IAAA,GAAOF,QAAA;EACPG,OAAA;EACAC,UAAA,GAAa;AACd,GAIG;EACF,OAAQC,EAAA,IAAoB;IAC3BA,EAAA,CAAGC,iBAAA,CAAkBP,iBAAA,EAAmBQ,kBAAkB;IAC1D,MAAMC,QAAA,GAAWN,IAAA,KAAS,QAAQA,IAAA,GAAOP,kBAAA,CAAmBO,IAAI;IAEhE,OAAOG,EAAA,CAAGI,GAAA,CACTb,QAAA,CAASc,MAAA,CAAO;MACfC,IAAA,EAAMZ,iBAAA;MACNa,MAAA,EAAQ,CAAC;MACTC,IAAA,EAAM;QACLX,IAAA,EAAMM,QAAA,KAAaR,QAAA,IAAYI,UAAA,GAAa,QAAQI,QAAA;QACpDL,OAAA,EAASW,MAAA,CAAOX,OAAO;MACxB;IACD,CAAC,CACF;EACD;AACD;AAEA,MAAMY,mBAAA,GAAsBxB,MAAA,CAAO;EAClCW,IAAA,EAAMT,MAAA,CAAO;EACbU,OAAA,EAASb,MAAA,CAAO;AACjB,CAAC;AAED,eAAeiB,mBACdS,eAAA,EACAC,YAAA,EACAC,IAAA,EACC;EACD,MAAMC,SAAA,GAAY,mBAAIC,GAAA,CAAY;EAClC,MAAMC,WAAA,GAAc,mBAAIC,GAAA,CAAoB;EAE5C,IAAI,CAACN,eAAA,CAAgBO,MAAA,EAAQ;IAC5B,MAAM,IAAIC,KAAA,CAAM,+CAA+C;EAChE;EAEA,WAAWC,OAAA,IAAWT,eAAA,CAAgBU,QAAA,EAAU;IAC/C,IAAID,OAAA,CAAQE,KAAA,KAAU,aAAaF,OAAA,CAAQG,OAAA,CAAQjB,IAAA,KAASZ,iBAAA,EAAmB;MAC9E,MAAM;QAAEG,IAAA;QAAMC;MAAQ,IAAIX,KAAA,CAAMuB,mBAAA,EAAqBU,OAAA,CAAQG,OAAA,CAAQf,IAAI;MAEzE,IAAIX,IAAA,KAAS,OAAO;QACnBiB,SAAA,CAAUV,GAAA,CAAIP,IAAI;MACnB;MAEAmB,WAAA,CAAYQ,GAAA,CAAI3B,IAAA,GAAOmB,WAAA,CAAYS,GAAA,CAAI5B,IAAI,KAAK,MAAMC,OAAO;IAC9D;EACD;EACA,MAAM4B,OAAA,GAAU,mBAAIX,GAAA,CAAY;EAEhC,WAAWY,KAAA,IAAShB,eAAA,CAAgBJ,MAAA,EAAQ;IAC3C,IAAIoB,KAAA,CAAMC,MAAA,EAAQC,gBAAA,EAAkB;MACnCH,OAAA,CAAQtB,GAAA,CAAIuB,KAAA,CAAMC,MAAA,CAAOC,gBAAA,CAAiBC,QAAQ;IACnD;IACA,IAAIH,KAAA,CAAMI,gBAAA,EAAkBD,QAAA,EAAU;MACrCJ,OAAA,CAAQtB,GAAA,CAAIuB,KAAA,CAAMI,gBAAA,CAAiBD,QAAQ;IAC5C;EACD;EAEA,MAAME,WAAA,GAAc,mBAAIf,GAAA,CAA0B;EAClD,MAAMgB,MAAA,GAASxC,SAAA,CAAUmB,YAAY;EACrC,MAAMsB,OAAA,CAAQC,GAAA,CACb,CAAC,GAAGrB,SAAS,EAAEsB,GAAA,CAAI,MAAOjC,QAAA,IAAa;IACtC6B,WAAA,CAAYR,GAAA,CACXrB,QAAA,EACA,MAAMkC,cAAA,CAAe;MACpBlC,QAAA;MACAL,OAAA,EAASkB,WAAA,CAAYS,GAAA,CAAItB,QAAQ;MACjC8B,MAAA;MACAK,KAAA,EAAO3B,eAAA,CAAgBO,MAAA;MACvBQ;IACD,CAAC,CACF;EACD,CAAC,CACF;EAEA,MAAMa,WAAA,GAAc,mBAAItB,GAAA,CAAsB;EAE9CsB,WAAA,CAAYf,GAAA,CAAI,OAAO;IAAEF,KAAA,EAAO;IAAWkB,OAAA,EAAS;EAAK,CAAC;EAE1D,WAAW,CAACC,KAAA,EAAOC,WAAW,KAAK/B,eAAA,CAAgBU,QAAA,CAASsB,OAAA,CAAQ,GAAG;IACtE,IAAID,WAAA,CAAYpB,KAAA,KAAU,aAAaoB,WAAA,CAAYnB,OAAA,CAAQjB,IAAA,KAASZ,iBAAA,EAAmB;MACtF;IACD;IAEA,MAAM;MAAEG,IAAA;MAAMC;IAAQ,IAAI4C,WAAA,CAAYnB,OAAA,CAAQf,IAAA;IAK9C,MAAMa,QAAA,GAAW,EAAC;IAElB,IAAI,CAACkB,WAAA,CAAYK,GAAA,CAAI/C,IAAI,GAAG;MAC3B,MAAM,CAACgD,KAAA,EAAO,GAAGC,IAAI,IAAId,WAAA,CAAYP,GAAA,CAAI5B,IAAI,EAAGuC,GAAA,CAAKW,IAAA,IACpDpC,eAAA,CAAgBqC,QAAA,CACf,UACAxD,MAAA,CAAOyD,SAAA,CAAU;QAChBnB,QAAA,EAAUiB,IAAA,CAAKG,YAAA;QACfC,MAAA,EAAQJ,IAAA,CAAKI,MAAA;QACbC,OAAA,EAASL,IAAA,CAAKK;MACf,CAAC,CACF,CACD;MAEA,IAAIN,IAAA,CAAKO,MAAA,GAAS,GAAG;QACpBhC,QAAA,CAASiC,IAAA,CAAK/D,QAAA,CAASgE,UAAA,CAAWV,KAAA,EAAOC,IAAI,CAAC;MAC/C;MAEAP,WAAA,CAAYf,GAAA,CAAI3B,IAAA,EAAMgD,KAAK;IAC5B;IAEAxB,QAAA,CAASiC,IAAA,CACR/D,QAAA,CAASiE,UAAA,CAAWjB,WAAA,CAAYd,GAAA,CAAI5B,IAAI,GAAI,CAC3Cc,eAAA,CAAgBqC,QAAA,CAAS,QAAQxD,MAAA,CAAOiE,IAAA,CAAKpE,GAAA,CAAIqE,GAAA,CAAI,EAAEC,SAAA,CAAU7D,OAAO,CAAC,CAAC,EAC1E,CACF;IAEAa,eAAA,CAAgBiD,cAAA,CAAenB,KAAA,EAAOpB,QAAQ;IAE9CV,eAAA,CAAgBkD,YAAA,CAAcC,GAAA,IAAQ;MACrC,IAAIA,GAAA,CAAIxC,KAAA,KAAU,YAAYwC,GAAA,CAAIC,MAAA,KAAWtB,KAAA,EAAO;QACnD,OAAO;UACNnB,KAAA,EAAO;UACP0C,YAAA,EAAc,CAACvB,KAAA,GAAQpB,QAAA,CAASgC,MAAA,GAAS,GAAG,CAAC;QAC9C;MACD;MAEA,OAAOS,GAAA;IACR,CAAC;EACF;EAEA,OAAOjD,IAAA,CAAK;AACb;AAEA,eAAewB,eAAe;EAC7BlC,QAAA;EACAL,OAAA;EACAmC,MAAA;EACAK,KAAA;EACAZ;AACD,GAM0B;EACzB,IAAIuC,gBAAA,GAAmBnE,OAAA;EACvB,MAAMoE,KAAA,GAAsB,EAAC;EAE7B,OAAOC,aAAA,CAAc;EAErB,eAAeA,cAAcC,MAAA,GAAwB,MAA6B;IACjF,MAAM;MAAE5D,IAAA;MAAM6D,WAAA;MAAaC;IAAW,IAAI,MAAMrC,MAAA,CAAOsC,QAAA,CAAS;MAAEjC,KAAA;MAAOnC,QAAA;MAAUiE;IAAO,CAAC;IAE3F,MAAMI,WAAA,GAAchE,IAAA,CAAKiE,IAAA,CAAK,CAACC,CAAA,EAAGC,CAAA,KAAMC,MAAA,CAAOnE,MAAA,CAAOkE,CAAA,CAAE7E,OAAO,IAAIW,MAAA,CAAOiE,CAAA,CAAE5E,OAAO,CAAC,CAAC;IAErF,WAAWiD,IAAA,IAAQyB,WAAA,EAAa;MAC/B,IAAI9C,OAAA,CAAQkB,GAAA,CAAIG,IAAA,CAAKG,YAAY,GAAG;QACnC;MACD;MAEA,MAAM2B,WAAA,GAAcpE,MAAA,CAAOsC,IAAA,CAAKjD,OAAO;MAEvCoE,KAAA,CAAMZ,IAAA,CAAKP,IAAI;MACfkB,gBAAA,IAAoBY,WAAA;MAEpB,IAAIZ,gBAAA,IAAoB,GAAG;QAC1B,OAAOC,KAAA;MACR;IACD;IAEA,IAAIG,WAAA,EAAa;MAChB,OAAOF,aAAA,CAAcG,UAAU;IAChC;IAEA,MAAM,IAAInD,KAAA,CAAM,4BAA4BhB,QAAQ,+BAA+B;EACpF;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}