{"ast":null,"code":"/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { aexists, anumber, aoutput } from './_assert.js';\nimport { byteSwap32, byteSwapIfBE, Hash, isLE, toBytes, u32 } from './utils.js';\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const SIGMA = /* @__PURE__ */new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n// Blake1, unused in others\n11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);\n/** Class, from which others are subclassed. */\nexport class BLAKE extends Hash {\n  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.length = 0;\n    this.pos = 0;\n    this.finished = false;\n    this.destroyed = false;\n    anumber(blockLen);\n    anumber(outputLen);\n    anumber(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen)) throw new Error('key length must be undefined or 1..' + keyLen);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen) throw new Error('salt must be undefined or ' + saltLen);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen) throw new Error('personalization must be undefined or ' + persLen);\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data) {\n    aexists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const {\n      blockLen,\n      buffer,\n      buffer32\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len;) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        if (!isLE) byteSwap32(buffer32);\n        this.compress(buffer32, 0, false);\n        if (!isLE) byteSwap32(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        if (!isLE) byteSwap32(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        if (!isLE) byteSwap32(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out) {\n    aexists(this);\n    aoutput(out, this);\n    const {\n      pos,\n      buffer32\n    } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    if (!isLE) byteSwap32(buffer32);\n    this.compress(buffer32, 0, true);\n    if (!isLE) byteSwap32(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => out32[i] = byteSwapIfBE(v));\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    const {\n      buffer,\n      length,\n      finished,\n      destroyed,\n      outputLen,\n      pos\n    } = this;\n    to || (to = new this.constructor({\n      dkLen: outputLen\n    }));\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}","map":{"version":3,"names":["aexists","anumber","aoutput","byteSwap32","byteSwapIfBE","Hash","isLE","toBytes","u32","SIGMA","Uint8Array","BLAKE","constructor","blockLen","outputLen","opts","keyLen","saltLen","persLen","length","pos","finished","destroyed","Error","key","undefined","salt","personalization","buffer","buffer32","update","data","len","offset","byteOffset","buf","compress","take","Math","min","dataOffset","data32","Uint32Array","floor","pos32","set","subarray","digestInto","out","fill","out32","get","forEach","v","i","digest","res","slice","destroy","_cloneInto","to","dkLen"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/sui/node_modules/@noble/hashes/src/_blake.ts"],"sourcesContent":["/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { aexists, anumber, aoutput } from './_assert.js';\nimport { type Input, byteSwap32, byteSwapIfBE, Hash, isLE, toBytes, u32 } from './utils.js';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const SIGMA: Uint8Array = /* @__PURE__ */ new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type BlakeOpts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE<T extends BLAKE<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected length: number = 0;\n  protected pos: number = 0;\n  protected finished = false;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    opts: BlakeOpts | undefined = {},\n    keyLen: number,\n    saltLen: number,\n    persLen: number\n  ) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    anumber(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n      throw new Error('key length must be undefined or 1..' + keyLen);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen)\n      throw new Error('salt must be undefined or ' + saltLen);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n      throw new Error('personalization must be undefined or ' + persLen);\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        if (!isLE) byteSwap32(buffer32);\n        this.compress(buffer32, 0, false);\n        if (!isLE) byteSwap32(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        if (!isLE) byteSwap32(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        if (!isLE) byteSwap32(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    if (!isLE) byteSwap32(buffer32);\n    this.compress(buffer32, 0, true);\n    if (!isLE) byteSwap32(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = byteSwapIfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\n"],"mappings":"AAAA;;;;AAIA,SAASA,OAAO,EAAEC,OAAO,EAAEC,OAAO,QAAQ,cAAc;AACxD,SAAqBC,UAAU,EAAEC,YAAY,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,GAAG,QAAQ,YAAY;AAE3F;;;;AAIA;AACA,OAAO,MAAMC,KAAK,GAAe,eAAgB,IAAIC,UAAU,CAAC,CAC9D,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EACpD,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EACpD,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EACpD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EACpD,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EACpD,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EACpD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EACpD,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;AACpD;AACA,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACpD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}