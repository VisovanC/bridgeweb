{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _pubkey, _signers;\nimport { toBase64 } from \"@mysten/bcs\";\nimport { Signer } from \"../cryptography/index.js\";\nclass MultiSigSigner extends Signer {\n  constructor(pubkey, signers = []) {\n    super();\n    __privateAdd(this, _pubkey);\n    __privateAdd(this, _signers);\n    __privateSet(this, _pubkey, pubkey);\n    __privateSet(this, _signers, signers);\n    let uniqueKeys = /* @__PURE__ */new Set();\n    let combinedWeight = 0;\n    const weights = pubkey.getPublicKeys().map(({\n      weight,\n      publicKey\n    }) => ({\n      weight,\n      address: publicKey.toSuiAddress()\n    }));\n    for (let signer of signers) {\n      const address = signer.toSuiAddress();\n      if (uniqueKeys.has(address)) {\n        throw new Error(`Can't create MultiSigSigner with duplicate signers`);\n      }\n      uniqueKeys.add(address);\n      const weight = weights.find(w => w.address === address)?.weight;\n      if (!weight) {\n        throw new Error(`Signer ${address} is not part of the MultiSig public key`);\n      }\n      combinedWeight += weight;\n    }\n    if (combinedWeight < pubkey.getThreshold()) {\n      throw new Error(`Combined weight of signers is less than threshold`);\n    }\n  }\n  getKeyScheme() {\n    return \"MultiSig\";\n  }\n  getPublicKey() {\n    return __privateGet(this, _pubkey);\n  }\n  sign(_data) {\n    throw new Error(\"MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead\");\n  }\n  signData(_data) {\n    throw new Error(\"MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead\");\n  }\n  async signTransaction(bytes) {\n    const signature = __privateGet(this, _pubkey).combinePartialSignatures(await Promise.all(__privateGet(this, _signers).map(async signer => (await signer.signTransaction(bytes)).signature)));\n    return {\n      signature,\n      bytes: toBase64(bytes)\n    };\n  }\n  async signPersonalMessage(bytes) {\n    const signature = __privateGet(this, _pubkey).combinePartialSignatures(await Promise.all(__privateGet(this, _signers).map(async signer => (await signer.signPersonalMessage(bytes)).signature)));\n    return {\n      signature,\n      bytes: toBase64(bytes)\n    };\n  }\n}\n_pubkey = new WeakMap();\n_signers = new WeakMap();\nexport { MultiSigSigner };","map":{"version":3,"names":["_pubkey","_signers","toBase64","Signer","MultiSigSigner","constructor","pubkey","signers","__privateAdd","__privateSet","uniqueKeys","Set","combinedWeight","weights","getPublicKeys","map","weight","publicKey","address","toSuiAddress","signer","has","Error","add","find","w","getThreshold","getKeyScheme","getPublicKey","__privateGet","sign","_data","signData","signTransaction","bytes","signature","combinePartialSignatures","Promise","all","signPersonalMessage","WeakMap"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/src/multisig/signer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { toBase64 } from '@mysten/bcs';\n\nimport type { SignatureScheme } from '../cryptography/index.js';\nimport { Signer } from '../cryptography/index.js';\nimport type { MultiSigPublicKey } from './publickey.js';\n\nexport class MultiSigSigner extends Signer {\n\t#pubkey: MultiSigPublicKey;\n\t#signers: Signer[];\n\n\tconstructor(pubkey: MultiSigPublicKey, signers: Signer[] = []) {\n\t\tsuper();\n\t\tthis.#pubkey = pubkey;\n\t\tthis.#signers = signers;\n\n\t\tlet uniqueKeys = new Set();\n\t\tlet combinedWeight = 0;\n\n\t\tconst weights = pubkey.getPublicKeys().map(({ weight, publicKey }) => ({\n\t\t\tweight,\n\t\t\taddress: publicKey.toSuiAddress(),\n\t\t}));\n\n\t\tfor (let signer of signers) {\n\t\t\tconst address = signer.toSuiAddress();\n\t\t\tif (uniqueKeys.has(address)) {\n\t\t\t\tthrow new Error(`Can't create MultiSigSigner with duplicate signers`);\n\t\t\t}\n\t\t\tuniqueKeys.add(address);\n\n\t\t\tconst weight = weights.find((w) => w.address === address)?.weight;\n\n\t\t\tif (!weight) {\n\t\t\t\tthrow new Error(`Signer ${address} is not part of the MultiSig public key`);\n\t\t\t}\n\n\t\t\tcombinedWeight += weight;\n\t\t}\n\n\t\tif (combinedWeight < pubkey.getThreshold()) {\n\t\t\tthrow new Error(`Combined weight of signers is less than threshold`);\n\t\t}\n\t}\n\n\tgetKeyScheme(): SignatureScheme {\n\t\treturn 'MultiSig';\n\t}\n\n\tgetPublicKey(): MultiSigPublicKey {\n\t\treturn this.#pubkey;\n\t}\n\n\tsign(_data: Uint8Array): never {\n\t\tthrow new Error(\n\t\t\t'MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead',\n\t\t);\n\t}\n\n\tsignData(_data: Uint8Array): never {\n\t\tthrow new Error(\n\t\t\t'MultiSigSigner does not support signing directly. Use signTransaction or signPersonalMessage instead',\n\t\t);\n\t}\n\n\tasync signTransaction(bytes: Uint8Array) {\n\t\tconst signature = this.#pubkey.combinePartialSignatures(\n\t\t\tawait Promise.all(\n\t\t\t\tthis.#signers.map(async (signer) => (await signer.signTransaction(bytes)).signature),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n\n\tasync signPersonalMessage(bytes: Uint8Array) {\n\t\tconst signature = this.#pubkey.combinePartialSignatures(\n\t\t\tawait Promise.all(\n\t\t\t\tthis.#signers.map(async (signer) => (await signer.signPersonalMessage(bytes)).signature),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,OAAA,EAAAC,QAAA;AAEA,SAASC,QAAA,QAAgB;AAGzB,SAASC,MAAA,QAAc;AAGhB,MAAMC,cAAA,SAAuBD,MAAA,CAAO;EAI1CE,YAAYC,MAAA,EAA2BC,OAAA,GAAoB,EAAC,EAAG;IAC9D,MAAM;IAJPC,YAAA,OAAAR,OAAA;IACAQ,YAAA,OAAAP,QAAA;IAICQ,YAAA,OAAKT,OAAA,EAAUM,MAAA;IACfG,YAAA,OAAKR,QAAA,EAAWM,OAAA;IAEhB,IAAIG,UAAA,GAAa,mBAAIC,GAAA,CAAI;IACzB,IAAIC,cAAA,GAAiB;IAErB,MAAMC,OAAA,GAAUP,MAAA,CAAOQ,aAAA,CAAc,EAAEC,GAAA,CAAI,CAAC;MAAEC,MAAA;MAAQC;IAAU,OAAO;MACtED,MAAA;MACAE,OAAA,EAASD,SAAA,CAAUE,YAAA,CAAa;IACjC,EAAE;IAEF,SAASC,MAAA,IAAUb,OAAA,EAAS;MAC3B,MAAMW,OAAA,GAAUE,MAAA,CAAOD,YAAA,CAAa;MACpC,IAAIT,UAAA,CAAWW,GAAA,CAAIH,OAAO,GAAG;QAC5B,MAAM,IAAII,KAAA,CAAM,oDAAoD;MACrE;MACAZ,UAAA,CAAWa,GAAA,CAAIL,OAAO;MAEtB,MAAMF,MAAA,GAASH,OAAA,CAAQW,IAAA,CAAMC,CAAA,IAAMA,CAAA,CAAEP,OAAA,KAAYA,OAAO,GAAGF,MAAA;MAE3D,IAAI,CAACA,MAAA,EAAQ;QACZ,MAAM,IAAIM,KAAA,CAAM,UAAUJ,OAAO,yCAAyC;MAC3E;MAEAN,cAAA,IAAkBI,MAAA;IACnB;IAEA,IAAIJ,cAAA,GAAiBN,MAAA,CAAOoB,YAAA,CAAa,GAAG;MAC3C,MAAM,IAAIJ,KAAA,CAAM,mDAAmD;IACpE;EACD;EAEAK,aAAA,EAAgC;IAC/B,OAAO;EACR;EAEAC,aAAA,EAAkC;IACjC,OAAOC,YAAA,OAAK7B,OAAA;EACb;EAEA8B,KAAKC,KAAA,EAA0B;IAC9B,MAAM,IAAIT,KAAA,CACT,sGACD;EACD;EAEAU,SAASD,KAAA,EAA0B;IAClC,MAAM,IAAIT,KAAA,CACT,sGACD;EACD;EAEA,MAAMW,gBAAgBC,KAAA,EAAmB;IACxC,MAAMC,SAAA,GAAYN,YAAA,OAAK7B,OAAA,EAAQoC,wBAAA,CAC9B,MAAMC,OAAA,CAAQC,GAAA,CACbT,YAAA,OAAK5B,QAAA,EAASc,GAAA,CAAI,MAAOK,MAAA,KAAY,MAAMA,MAAA,CAAOa,eAAA,CAAgBC,KAAK,GAAGC,SAAS,CACpF,CACD;IAEA,OAAO;MACNA,SAAA;MACAD,KAAA,EAAOhC,QAAA,CAASgC,KAAK;IACtB;EACD;EAEA,MAAMK,oBAAoBL,KAAA,EAAmB;IAC5C,MAAMC,SAAA,GAAYN,YAAA,OAAK7B,OAAA,EAAQoC,wBAAA,CAC9B,MAAMC,OAAA,CAAQC,GAAA,CACbT,YAAA,OAAK5B,QAAA,EAASc,GAAA,CAAI,MAAOK,MAAA,KAAY,MAAMA,MAAA,CAAOmB,mBAAA,CAAoBL,KAAK,GAAGC,SAAS,CACxF,CACD;IAEA,OAAO;MACNA,SAAA;MACAD,KAAA,EAAOhC,QAAA,CAASgC,KAAK;IACtB;EACD;AACD;AAlFClC,OAAA,OAAAwC,OAAA;AACAvC,QAAA,OAAAuC,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}