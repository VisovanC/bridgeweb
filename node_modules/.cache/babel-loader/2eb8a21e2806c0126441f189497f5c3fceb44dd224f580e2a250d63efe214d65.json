{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _blockData, _input, input_fn, _normalizeTransactionArgument, normalizeTransactionArgument_fn, _getConfig, getConfig_fn, _validate, validate_fn, _prepareGasPayment, prepareGasPayment_fn, _prepareGasPrice, prepareGasPrice_fn, _prepareTransactions, prepareTransactions_fn, _prepare, prepare_fn;\nimport { fromB64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, mask } from \"superstruct\";\nimport { bcs } from \"../bcs/index.js\";\nimport { SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { normalizeSuiAddress, normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { BuilderCallArg, getIdFromCallArg, Inputs, isMutableSharedObjectInput, ObjectCallArg, PureCallArg, SuiObjectRef } from \"./Inputs.js\";\nimport { createPure } from \"./pure.js\";\nimport { getPureSerializationType, isTxContext } from \"./serializer.js\";\nimport { TransactionBlockDataBuilder } from \"./TransactionBlockData.js\";\nimport { TransactionBlockInput, Transactions } from \"./Transactions.js\";\nimport { create, extractMutableReference, extractReference, extractStructTag } from \"./utils.js\";\nconst DefaultOfflineLimits = {\n  maxPureArgumentSize: 16 * 1024,\n  maxTxGas: 5e10,\n  maxGasObjects: 256,\n  maxTxSizeBytes: 128 * 1024\n};\nfunction createTransactionResult(index) {\n  const baseResult = {\n    kind: \"Result\",\n    index\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    kind: \"NestedResult\",\n    index,\n    resultIndex\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (true) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nfunction isReceivingType(normalizedType) {\n  const tag = extractStructTag(normalizedType);\n  if (tag) {\n    return tag.Struct.address === \"0x2\" && tag.Struct.module === \"transfer\" && tag.Struct.name === \"Receiving\";\n  }\n  return false;\n}\nfunction expectClient(options) {\n  if (!options.client) {\n    throw new Error(`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.client;\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nconst LIMITS = {\n  // The maximum gas that is allowed.\n  maxTxGas: \"max_tx_gas\",\n  // The maximum number of gas objects that can be selected for one transaction.\n  maxGasObjects: \"max_gas_payment_objects\",\n  // The maximum size (in bytes) that the transaction can be:\n  maxTxSizeBytes: \"max_tx_size_bytes\",\n  // The maximum size (in bytes) that pure arguments can be:\n  maxPureArgumentSize: \"max_pure_argument_size\"\n};\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst chunk = (arr, size) => Array.from({\n  length: Math.ceil(arr.length / size)\n}, (_, i) => arr.slice(i * size, i * size + size));\nfunction isTransactionBlock(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst _TransactionBlock = class {\n  constructor(transaction) {\n    /**\n     * Dynamically create a new input, which is separate from the `input`. This is important\n     * for generated clients to be able to define unique inputs that are non-overlapping with the\n     * defined inputs.\n     *\n     * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n     * is the format required for custom serialization.\n     *\n     */\n    __privateAdd(this, _input);\n    __privateAdd(this, _normalizeTransactionArgument);\n    __privateAdd(this, _getConfig);\n    __privateAdd(this, _validate);\n    // The current default is just picking _all_ coins we can which may not be ideal.\n    __privateAdd(this, _prepareGasPayment);\n    __privateAdd(this, _prepareGasPrice);\n    __privateAdd(this, _prepareTransactions);\n    /**\n     * Prepare the transaction by valdiating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    __privateAdd(this, _prepare);\n    __privateAdd(this, _blockData, void 0);\n    __privateSet(this, _blockData, new TransactionBlockDataBuilder(transaction ? transaction.blockData : void 0));\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _TransactionBlock();\n    __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromB64(serialized) : serialized));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(serialized) {\n    const tx = new _TransactionBlock();\n    if (typeof serialized !== \"string\" || !serialized.startsWith(\"{\")) {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromBytes(typeof serialized === \"string\" ? fromB64(serialized) : serialized));\n    } else {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.restore(JSON.parse(serialized)));\n    }\n    return tx;\n  }\n  setSender(sender) {\n    __privateGet(this, _blockData).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _blockData).sender) {\n      __privateGet(this, _blockData).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _blockData).expiration = expiration;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _blockData).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _blockData).gasConfig.budget = String(budget);\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _blockData).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _blockData).gasConfig.payment = payments.map(payment => mask(payment, SuiObjectRef));\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  get blockData() {\n    return __privateGet(this, _blockData).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure((value, type) => {\n        if (isSerializedBcs(value)) {\n          return __privateMethod(this, _input, input_fn).call(this, \"pure\", {\n            Pure: Array.from(value.toBytes())\n          });\n        }\n        return __privateMethod(this, _input, input_fn).call(this, \"pure\", value instanceof Uint8Array ? Inputs.Pure(value) : type ? Inputs.Pure(value, type) : value);\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      kind: \"GasCoin\"\n    };\n  }\n  /**\n   * Add a new object input to the transaction.\n   */\n  object(value) {\n    if (typeof value === \"object\" && \"kind\" in value) {\n      return value;\n    }\n    const id = getIdFromCallArg(value);\n    const inserted = __privateGet(this, _blockData).inputs.find(i => i.type === \"object\" && id === getIdFromCallArg(i.value));\n    if (inserted && is(inserted.value, ObjectCallArg) && \"Shared\" in inserted.value.Object && is(value, ObjectCallArg) && \"Shared\" in value.Object) {\n      inserted.value.Object.Shared.mutable = inserted.value.Object.Shared.mutable || value.Object.Shared.mutable;\n    }\n    return inserted ?? __privateMethod(this, _input, input_fn).call(this, \"object\", typeof value === \"string\" ? normalizeSuiAddress(value) : value);\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  /** Add a transaction to the transaction block. */\n  add(transaction) {\n    const index = __privateGet(this, _blockData).transactions.push(transaction);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    return this.add(Transactions.SplitCoins(typeof coin === \"string\" ? this.object(coin) : coin, amounts.map(amount => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, amount))));\n  }\n  mergeCoins(destination, sources) {\n    return this.add(Transactions.MergeCoins(typeof destination === \"string\" ? this.object(destination) : destination, sources.map(src => typeof src === \"string\" ? this.object(src) : src)));\n  }\n  publish({\n    modules,\n    dependencies\n  }) {\n    return this.add(Transactions.Publish({\n      modules,\n      dependencies\n    }));\n  }\n  upgrade({\n    modules,\n    dependencies,\n    packageId,\n    ticket\n  }) {\n    return this.add(Transactions.Upgrade({\n      modules,\n      dependencies,\n      packageId,\n      ticket: typeof ticket === \"string\" ? this.object(ticket) : ticket\n    }));\n  }\n  moveCall({\n    arguments: args,\n    typeArguments,\n    target\n  }) {\n    return this.add(Transactions.MoveCall({\n      arguments: args?.map(arg => __privateMethod(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, arg)),\n      typeArguments,\n      target\n    }));\n  }\n  transferObjects(objects, address) {\n    return this.add(Transactions.TransferObjects(objects.map(obj => typeof obj === \"string\" ? this.object(obj) : obj), typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _normalizeTransactionArgument, normalizeTransactionArgument_fn).call(this, address)));\n  }\n  makeMoveVec({\n    type,\n    objects\n  }) {\n    return this.add(Transactions.MakeMoveVec({\n      type,\n      objects: objects.map(obj => typeof obj === \"string\" ? this.object(obj) : obj)\n    }));\n  }\n  /**\n   * Serialize the transaction to a string so that it can be sent to a separate context.\n   * This is different from `build` in that it does not serialize to BCS bytes, and instead\n   * uses a separate format that is unique to the transaction builder. This allows\n   * us to serialize partially-complete transactions, that can then be completed and\n   * built in a separate context.\n   *\n   * For example, a dapp can construct a transaction, but not provide gas objects\n   * or a gas budget. The transaction then can be sent to the wallet, where this\n   * information is automatically filled in (e.g. by querying for coin objects\n   * and performing a dry run).\n   */\n  serialize() {\n    return JSON.stringify(__privateGet(this, _blockData).snapshot());\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const {\n      signer,\n      ...buildOptions\n    } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransactionBlock(bytes);\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await __privateMethod(this, _prepare, prepare_fn).call(this, options);\n    return __privateGet(this, _blockData).build({\n      maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await __privateMethod(this, _prepare, prepare_fn).call(this, options);\n    return __privateGet(this, _blockData).getDigest();\n  }\n};\nlet TransactionBlock = _TransactionBlock;\n_blockData = new WeakMap();\n_input = new WeakSet();\ninput_fn = function (type, value) {\n  const index = __privateGet(this, _blockData).inputs.length;\n  const input = create({\n    kind: \"Input\",\n    // bigints can't be serialized to JSON, so just string-convert them here:\n    value: typeof value === \"bigint\" ? String(value) : value,\n    index,\n    type\n  }, TransactionBlockInput);\n  __privateGet(this, _blockData).inputs.push(input);\n  return input;\n};\n_normalizeTransactionArgument = new WeakSet();\nnormalizeTransactionArgument_fn = function (arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return arg;\n};\n_getConfig = new WeakSet();\ngetConfig_fn = function (key, {\n  protocolConfig,\n  limits\n}) {\n  if (limits && typeof limits[key] === \"number\") {\n    return limits[key];\n  }\n  if (!protocolConfig) {\n    return DefaultOfflineLimits[key];\n  }\n  const attribute = protocolConfig?.attributes[LIMITS[key]];\n  if (!attribute) {\n    throw new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n  }\n  const value = \"u64\" in attribute ? attribute.u64 : \"u32\" in attribute ? attribute.u32 : attribute.f64;\n  if (!value) {\n    throw new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n  }\n  return Number(value);\n};\n_validate = new WeakSet();\nvalidate_fn = function (options) {\n  const maxPureArgumentSize = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxPureArgumentSize\", options);\n  __privateGet(this, _blockData).inputs.forEach((input, index) => {\n    if (is(input.value, PureCallArg)) {\n      if (input.value.Pure.length > maxPureArgumentSize) {\n        throw new Error(`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`);\n      }\n    }\n  });\n};\n_prepareGasPayment = new WeakSet();\nprepareGasPayment_fn = async function (options) {\n  if (__privateGet(this, _blockData).gasConfig.payment) {\n    const maxGasObjects = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options);\n    if (__privateGet(this, _blockData).gasConfig.payment.length > maxGasObjects) {\n      throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n    }\n  }\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.payment) {\n    return;\n  }\n  const gasOwner = __privateGet(this, _blockData).gasConfig.owner ?? __privateGet(this, _blockData).sender;\n  const coins = await expectClient(options).getCoins({\n    owner: gasOwner,\n    coinType: SUI_TYPE_ARG\n  });\n  const paymentCoins = coins.data.filter(coin => {\n    const matchingInput = __privateGet(this, _blockData).inputs.find(input => {\n      if (is(input.value, BuilderCallArg) && \"Object\" in input.value && \"ImmOrOwned\" in input.value.Object) {\n        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n      }\n      return false;\n    });\n    return !matchingInput;\n  }).slice(0, __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options) - 1).map(coin => ({\n    objectId: coin.coinObjectId,\n    digest: coin.digest,\n    version: coin.version\n  }));\n  if (!paymentCoins.length) {\n    throw new Error(\"No valid gas coins found for the transaction.\");\n  }\n  this.setGasPayment(paymentCoins);\n};\n_prepareGasPrice = new WeakSet();\nprepareGasPrice_fn = async function (options) {\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.price) {\n    return;\n  }\n  this.setGasPrice(await expectClient(options).getReferenceGasPrice());\n};\n_prepareTransactions = new WeakSet();\nprepareTransactions_fn = async function (options) {\n  const {\n    inputs,\n    transactions\n  } = __privateGet(this, _blockData);\n  const moveModulesToResolve = [];\n  const objectsToResolve = [];\n  inputs.forEach(input => {\n    if (input.type === \"object\" && typeof input.value === \"string\") {\n      objectsToResolve.push({\n        id: normalizeSuiAddress(input.value),\n        input\n      });\n      return;\n    }\n  });\n  transactions.forEach(transaction => {\n    if (transaction.kind === \"MoveCall\") {\n      const needsResolution = transaction.arguments.some(arg => arg.kind === \"Input\" && !is(inputs[arg.index].value, BuilderCallArg));\n      if (needsResolution) {\n        moveModulesToResolve.push(transaction);\n      }\n    }\n    if (transaction.kind === \"SplitCoins\") {\n      transaction.amounts.forEach(amount => {\n        if (amount.kind === \"Input\") {\n          const input = inputs[amount.index];\n          if (typeof input.value !== \"object\") {\n            input.value = Inputs.Pure(bcs.U64.serialize(input.value));\n          }\n        }\n      });\n    }\n    if (transaction.kind === \"TransferObjects\") {\n      if (transaction.address.kind === \"Input\") {\n        const input = inputs[transaction.address.index];\n        if (typeof input.value !== \"object\") {\n          input.value = Inputs.Pure(bcs.Address.serialize(input.value));\n        }\n      }\n    }\n  });\n  if (moveModulesToResolve.length) {\n    await Promise.all(moveModulesToResolve.map(async moveCall => {\n      const [packageId, moduleName, functionName] = moveCall.target.split(\"::\");\n      const normalized = await expectClient(options).getNormalizedMoveFunction({\n        package: normalizeSuiObjectId(packageId),\n        module: moduleName,\n        function: functionName\n      });\n      const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));\n      const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;\n      if (params.length !== moveCall.arguments.length) {\n        throw new Error(\"Incorrect number of arguments.\");\n      }\n      params.forEach((param, i) => {\n        const arg = moveCall.arguments[i];\n        if (arg.kind !== \"Input\") return;\n        const input = inputs[arg.index];\n        if (is(input.value, BuilderCallArg)) return;\n        const inputValue = input.value;\n        const serType = getPureSerializationType(param, inputValue);\n        if (serType) {\n          input.value = Inputs.Pure(inputValue, serType);\n          return;\n        }\n        const structVal = extractStructTag(param);\n        if (structVal != null || typeof param === \"object\" && \"TypeParameter\" in param) {\n          if (typeof inputValue !== \"string\") {\n            throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);\n          }\n          objectsToResolve.push({\n            id: inputValue,\n            input,\n            normalizedType: param\n          });\n          return;\n        }\n        throw new Error(`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(inputValue, null, 2)}`);\n      });\n    }));\n  }\n  if (objectsToResolve.length) {\n    const dedupedIds = [...new Set(objectsToResolve.map(({\n      id\n    }) => id))];\n    const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n    const objects = (await Promise.all(objectChunks.map(chunk2 => expectClient(options).multiGetObjects({\n      ids: chunk2,\n      options: {\n        showOwner: true\n      }\n    })))).flat();\n    let objectsById = new Map(dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    }));\n    const invalidObjects = Array.from(objectsById).filter(([_, obj]) => obj.error).map(([id, _]) => id);\n    if (invalidObjects.length) {\n      throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n    }\n    objectsToResolve.forEach(({\n      id,\n      input,\n      normalizedType\n    }) => {\n      const object = objectsById.get(id);\n      const owner = object.data?.owner;\n      const initialSharedVersion = owner && typeof owner === \"object\" && \"Shared\" in owner ? owner.Shared.initial_shared_version : void 0;\n      if (initialSharedVersion) {\n        const isByValue = normalizedType != null && extractMutableReference(normalizedType) == null && extractReference(normalizedType) == null;\n        const mutable = isMutableSharedObjectInput(input.value) || isByValue || normalizedType != null && extractMutableReference(normalizedType) != null;\n        input.value = Inputs.SharedObjectRef({\n          objectId: id,\n          initialSharedVersion,\n          mutable\n        });\n      } else if (normalizedType && isReceivingType(normalizedType)) {\n        input.value = Inputs.ReceivingRef(object.data);\n      } else {\n        input.value = Inputs.ObjectRef(object.data);\n      }\n    });\n  }\n};\n_prepare = new WeakSet();\nprepare_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _blockData).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  if (!options.protocolConfig && !options.limits && options.client) {\n    options.protocolConfig = await options.client.getProtocolConfig();\n  }\n  await Promise.all([__privateMethod(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);\n  if (!options.onlyTransactionKind) {\n    await __privateMethod(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);\n    if (!__privateGet(this, _blockData).gasConfig.budget) {\n      const dryRunResult = await expectClient(options).dryRunTransactionBlock({\n        transactionBlock: __privateGet(this, _blockData).build({\n          maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n          overrides: {\n            gasConfig: {\n              budget: String(__privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxGas\", options)),\n              payment: []\n            }\n          }\n        })\n      });\n      if (dryRunResult.effects.status.status !== \"success\") {\n        throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {\n          cause: dryRunResult\n        });\n      }\n      const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n      const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n      const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n      this.setGasBudget(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n    }\n  }\n  __privateMethod(this, _validate, validate_fn).call(this, options);\n};\nexport { TransactionBlock, isTransactionBlock };","map":{"version":3,"names":["_blockData","_input","input_fn","_normalizeTransactionArgument","normalizeTransactionArgument_fn","_getConfig","getConfig_fn","_validate","validate_fn","_prepareGasPayment","prepareGasPayment_fn","_prepareGasPrice","prepareGasPrice_fn","_prepareTransactions","prepareTransactions_fn","_prepare","prepare_fn","fromB64","isSerializedBcs","is","mask","bcs","SUI_TYPE_ARG","normalizeSuiAddress","normalizeSuiObjectId","BuilderCallArg","getIdFromCallArg","Inputs","isMutableSharedObjectInput","ObjectCallArg","PureCallArg","SuiObjectRef","createPure","getPureSerializationType","isTxContext","TransactionBlockDataBuilder","TransactionBlockInput","Transactions","create","extractMutableReference","extractReference","extractStructTag","DefaultOfflineLimits","maxPureArgumentSize","maxTxGas","maxGasObjects","maxTxSizeBytes","createTransactionResult","index","baseResult","kind","nestedResults","nestedResultFor","resultIndex","Proxy","set","Error","get","target","property","Reflect","Symbol","iterator","i","parseInt","Number","isNaN","isReceivingType","normalizedType","tag","Struct","address","module","name","expectClient","options","client","TRANSACTION_BRAND","for","LIMITS","GAS_SAFE_OVERHEAD","MAX_OBJECTS_PER_FETCH","chunk","arr","size","Array","from","length","Math","ceil","_","slice","isTransactionBlock","obj","_TransactionBlock","constructor","transaction","__privateAdd","__privateSet","blockData","fromKind","serialized","tx","fromKindBytes","startsWith","fromBytes","restore","JSON","parse","setSender","sender","__privateGet","setSenderIfNotSet","setExpiration","expiration","setGasPrice","price","gasConfig","String","setGasBudget","budget","setGasOwner","owner","setGasPayment","payments","payment","map","snapshot","pure","Object","defineProperty","enumerable","value","type","__privateMethod","call","Pure","toBytes","Uint8Array","gas","object","id","inserted","inputs","find","Shared","mutable","objectRef","args","ObjectRef","receivingRef","ReceivingRef","sharedObjectRef","SharedObjectRef","add","transactions","push","splitCoins","coin","amounts","SplitCoins","amount","u64","mergeCoins","destination","sources","MergeCoins","src","publish","modules","dependencies","Publish","upgrade","packageId","ticket","Upgrade","moveCall","arguments","typeArguments","MoveCall","arg","transferObjects","objects","TransferObjects","makeMoveVec","MakeMoveVec","serialize","stringify","sign","signer","buildOptions","bytes","build","signTransactionBlock","maxSizeBytes","onlyTransactionKind","getDigest","TransactionBlock","WeakMap","WeakSet","input","key","protocolConfig","limits","attribute","attributes","u32","f64","forEach","gasOwner","coins","getCoins","coinType","paymentCoins","data","filter","matchingInput","coinObjectId","ImmOrOwned","objectId","digest","version","getReferenceGasPrice","moveModulesToResolve","objectsToResolve","needsResolution","some","U64","Address","Promise","all","moduleName","functionName","split","normalized","getNormalizedMoveFunction","package","function","hasTxContext","parameters","at","params","param","inputValue","serType","structVal","dedupedIds","Set","objectChunks","chunk2","multiGetObjects","ids","showOwner","flat","objectsById","Map","invalidObjects","error","join","initialSharedVersion","initial_shared_version","isByValue","getProtocolConfig","dryRunResult","dryRunTransactionBlock","transactionBlock","overrides","effects","status","cause","safeOverhead","BigInt","baseComputationCostWithOverhead","gasUsed","computationCost","gasBudget","storageCost","storageRebate"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/sui.js/src/transactions/TransactionBlock.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { ProtocolConfig, SuiClient, SuiMoveNormalizedType } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { SUI_TYPE_ARG } from '../utils/index.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId } from '../utils/sui-types.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tObjectCallArg,\n\tPureCallArg,\n\tSuiObjectRef,\n} from './Inputs.js';\nimport { createPure } from './pure.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { MoveCallTransaction, TransactionArgument, TransactionType } from './Transactions.js';\nimport { TransactionBlockInput, Transactions } from './Transactions.js';\nimport { create, extractMutableReference, extractReference, extractStructTag } from './utils.js';\n\nexport type TransactionObjectArgument = Exclude<\n\tTransactionArgument,\n\t{ kind: 'Input'; type: 'pure' }\n>;\n\nexport type TransactionResult = Extract<TransactionArgument, { kind: 'Result' }> &\n\tExtract<TransactionArgument, { kind: 'NestedResult' }>[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction isReceivingType(normalizedType: SuiMoveNormalizedType): boolean {\n\tconst tag = extractStructTag(normalizedType);\n\tif (tag) {\n\t\treturn (\n\t\t\ttag.Struct.address === '0x2' &&\n\t\t\ttag.Struct.module === 'transfer' &&\n\t\t\ttag.Struct.name === 'Receiving'\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction expectClient(options: BuildOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\ninterface SignOptions extends BuildOptions {\n\tsigner: Signer;\n}\n\nexport function isTransactionBlock(obj: unknown): obj is TransactionBlock {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value, type) => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#input('pure', {\n\t\t\t\t\t\tPure: Array.from(value.toBytes()),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#input(\n\t\t\t\t\t'pure',\n\t\t\t\t\tvalue instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: type\n\t\t\t\t\t\t? Inputs.Pure(value, type)\n\t\t\t\t\t\t: value,\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionObjectArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input<T extends 'object' | 'pure'>(type: T, value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input as Extract<typeof input, { type: T }>;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput) {\n\t\tif (typeof value === 'object' && 'kind' in value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t) as Extract<TransactionArgument, { type?: 'object' }> | undefined;\n\n\t\t// Upgrade shared object inputs to mutable if needed:\n\t\tif (\n\t\t\tinserted &&\n\t\t\tis(inserted.value, ObjectCallArg) &&\n\t\t\t'Shared' in inserted.value.Object &&\n\t\t\tis(value, ObjectCallArg) &&\n\t\t\t'Shared' in value.Object\n\t\t) {\n\t\t\tinserted.value.Object.Shared.mutable =\n\t\t\t\tinserted.value.Object.Shared.mutable || value.Object.Shared.mutable;\n\t\t}\n\n\t\treturn (\n\t\t\tinserted ??\n\t\t\tthis.#input('object', typeof value === 'string' ? normalizeSuiAddress(value) : value)\n\t\t);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(\n\t\targ: TransactionArgument | SerializedBcs<any>,\n\t): TransactionArgument {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn arg as TransactionArgument;\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : coin,\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.MergeCoins(\n\t\t\t\ttypeof destination === 'string' ? this.object(destination) : destination,\n\t\t\t\tsources.map((src) => (typeof src === 'string' ? this.object(src) : src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactions.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackageId,\n\t\t\t\tticket: typeof ticket === 'string' ? this.object(ticket) : ticket,\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\ttypeArguments,\n\t\ttarget,\n\t}: {\n\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\ttypeArguments?: string[];\n\t\ttarget: `${string}::${string}::${string}`;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MoveCall({\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t\ttypeArguments,\n\t\t\t\ttarget,\n\t\t\t}),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.TransferObjects(\n\t\t\t\tobjects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: {\n\t\tobjects: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\tobjects: objects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransactionBlock(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectClient(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectClient(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (input.type === 'object' && typeof input.value === 'string') {\n\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\tobjectsToResolve.push({ id: normalizeSuiAddress(input.value), input });\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t\t// This should only happen when transaction block data was hydrated from an old version of the SDK\n\t\t\tif (transaction.kind === 'SplitCoins') {\n\t\t\t\ttransaction.amounts.forEach((amount) => {\n\t\t\t\t\tif (amount.kind === 'Input') {\n\t\t\t\t\t\tconst input = inputs[amount.index];\n\t\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (transaction.kind === 'TransferObjects') {\n\t\t\t\tif (transaction.address.kind === 'Input') {\n\t\t\t\t\tconst input = inputs[transaction.address.index];\n\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.Address.serialize(input.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectClient(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectClient(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst owner = object.data?.owner;\n\t\t\t\tconst initialSharedVersion =\n\t\t\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference or taken by value, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst isByValue =\n\t\t\t\t\t\tnormalizedType != null &&\n\t\t\t\t\t\textractMutableReference(normalizedType) == null &&\n\t\t\t\t\t\textractReference(normalizedType) == null;\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\tisByValue ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else if (normalizedType && isReceivingType(normalizedType)) {\n\t\t\t\t\tinput.value = Inputs.ReceivingRef(object.data!);\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(object.data!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.client) {\n\t\t\toptions.protocolConfig = await options.client.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectClient(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}