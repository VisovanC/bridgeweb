{"ast":null,"code":"import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { bcs } from \"../bcs/index.js\";\nimport { bytesEqual, PublicKey } from \"../cryptography/publickey.js\";\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from \"../cryptography/signature-scheme.js\";\nimport { parseSerializedSignature } from \"../cryptography/signature.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { publicKeyFromRawBytes } from \"../verify/index.js\";\nimport { toZkLoginPublicIdentifier } from \"../zklogin/publickey.js\";\nimport { MultiSigSigner } from \"./signer.js\";\nconst MAX_SIGNER_IN_MULTISIG = 10;\nconst MIN_SIGNER_IN_MULTISIG = 1;\nclass MultiSigPublicKey extends PublicKey {\n  /**\n   * Create a new MultiSigPublicKey object\n   */\n  constructor(value, options = {}) {\n    super();\n    if (typeof value === \"string\") {\n      this.rawBytes = fromBase64(value);\n      this.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n    } else if (value instanceof Uint8Array) {\n      this.rawBytes = value;\n      this.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n    } else {\n      this.multisigPublicKey = value;\n      this.rawBytes = bcs.MultiSigPublicKey.serialize(value).toBytes();\n    }\n    if (this.multisigPublicKey.threshold < 1) {\n      throw new Error(\"Invalid threshold\");\n    }\n    const seenPublicKeys = /* @__PURE__ */new Set();\n    this.publicKeys = this.multisigPublicKey.pk_map.map(({\n      pubKey,\n      weight\n    }) => {\n      const [scheme, bytes] = Object.entries(pubKey).filter(([name]) => name !== \"$kind\")[0];\n      const publicKeyStr = Uint8Array.from(bytes).toString();\n      if (seenPublicKeys.has(publicKeyStr)) {\n        throw new Error(`Multisig does not support duplicate public keys`);\n      }\n      seenPublicKeys.add(publicKeyStr);\n      if (weight < 1) {\n        throw new Error(`Invalid weight`);\n      }\n      return {\n        publicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),\n        weight\n      };\n    });\n    const totalWeight = this.publicKeys.reduce((sum, {\n      weight\n    }) => sum + weight, 0);\n    if (this.multisigPublicKey.threshold > totalWeight) {\n      throw new Error(`Unreachable threshold`);\n    }\n    if (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {\n      throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n    }\n    if (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {\n      throw new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);\n    }\n  }\n  /**\n   * \tA static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.\n   */\n  static fromPublicKeys({\n    threshold,\n    publicKeys\n  }) {\n    return new MultiSigPublicKey({\n      pk_map: publicKeys.map(({\n        publicKey,\n        weight\n      }) => {\n        const scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag()];\n        return {\n          pubKey: {\n            [scheme]: Array.from(publicKey.toRawBytes())\n          },\n          weight\n        };\n      }),\n      threshold\n    });\n  }\n  /**\n   * Checks if two MultiSig public keys are equal\n   */\n  equals(publicKey) {\n    return super.equals(publicKey);\n  }\n  /**\n   * Return the byte array representation of the MultiSig public key\n   */\n  toRawBytes() {\n    return this.rawBytes;\n  }\n  getPublicKeys() {\n    return this.publicKeys;\n  }\n  getThreshold() {\n    return this.multisigPublicKey.threshold;\n  }\n  getSigner(...signers) {\n    return new MultiSigSigner(this, signers);\n  }\n  /**\n   * Return the Sui address associated with this MultiSig public key\n   */\n  toSuiAddress() {\n    const maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n    const tmp = new Uint8Array(maxLength);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]]);\n    tmp.set(bcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);\n    let i = 3;\n    for (const {\n      publicKey,\n      weight\n    } of this.publicKeys) {\n      const bytes = publicKey.toSuiBytes();\n      tmp.set(bytes, i);\n      i += bytes.length;\n      tmp.set([weight], i++);\n    }\n    return normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), {\n      dkLen: 32\n    })));\n  }\n  /**\n   * Return the Sui address associated with this MultiSig public key\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"];\n  }\n  /**\n   * Verifies that the signature is valid for for the provided message\n   */\n  async verify(message, multisigSignature) {\n    const parsed = parseSerializedSignature(multisigSignature);\n    if (parsed.signatureScheme !== \"MultiSig\") {\n      throw new Error(\"Invalid signature scheme\");\n    }\n    const {\n      multisig\n    } = parsed;\n    let signatureWeight = 0;\n    if (!bytesEqual(bcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(), bcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes())) {\n      return false;\n    }\n    for (const {\n      publicKey,\n      weight,\n      signature\n    } of parsePartialSignatures(multisig)) {\n      if (!(await publicKey.verify(message, signature))) {\n        return false;\n      }\n      signatureWeight += weight;\n    }\n    return signatureWeight >= this.multisigPublicKey.threshold;\n  }\n  /**\n   * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once\n   * and that all the public keys involved are known and valid, and then serializes multisig into the standard format\n   */\n  combinePartialSignatures(signatures) {\n    if (signatures.length > MAX_SIGNER_IN_MULTISIG) {\n      throw new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n    }\n    let bitmap = 0;\n    const compressedSignatures = new Array(signatures.length);\n    for (let i = 0; i < signatures.length; i++) {\n      let parsed = parseSerializedSignature(signatures[i]);\n      if (parsed.signatureScheme === \"MultiSig\") {\n        throw new Error(\"MultiSig is not supported inside MultiSig\");\n      }\n      let publicKey;\n      if (parsed.signatureScheme === \"ZkLogin\") {\n        publicKey = toZkLoginPublicIdentifier(parsed.zkLogin?.addressSeed, parsed.zkLogin?.iss).toRawBytes();\n      } else {\n        publicKey = parsed.publicKey;\n      }\n      compressedSignatures[i] = {\n        [parsed.signatureScheme]: Array.from(parsed.signature.map(x => Number(x)))\n      };\n      let publicKeyIndex;\n      for (let j = 0; j < this.publicKeys.length; j++) {\n        if (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {\n          if (bitmap & 1 << j) {\n            throw new Error(\"Received multiple signatures from the same public key\");\n          }\n          publicKeyIndex = j;\n          break;\n        }\n      }\n      if (publicKeyIndex === void 0) {\n        throw new Error(\"Received signature from unknown public key\");\n      }\n      bitmap |= 1 << publicKeyIndex;\n    }\n    let multisig = {\n      sigs: compressedSignatures,\n      bitmap,\n      multisig_pk: this.multisigPublicKey\n    };\n    const bytes = bcs.MultiSig.serialize(multisig, {\n      maxSize: 8192\n    }).toBytes();\n    let tmp = new Uint8Array(bytes.length + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]]);\n    tmp.set(bytes, 1);\n    return toBase64(tmp);\n  }\n}\nfunction parsePartialSignatures(multisig, options = {}) {\n  let res = new Array(multisig.sigs.length);\n  for (let i = 0; i < multisig.sigs.length; i++) {\n    const [signatureScheme, signature] = Object.entries(multisig.sigs[i]).filter(([name]) => name !== \"$kind\")[0];\n    const pkIndex = asIndices(multisig.bitmap).at(i);\n    const pair = multisig.multisig_pk.pk_map[pkIndex];\n    const pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);\n    if (signatureScheme === \"MultiSig\") {\n      throw new Error(\"MultiSig is not supported inside MultiSig\");\n    }\n    const publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);\n    res[i] = {\n      signatureScheme,\n      signature: Uint8Array.from(signature),\n      publicKey,\n      weight: pair.weight\n    };\n  }\n  return res;\n}\nfunction asIndices(bitmap) {\n  if (bitmap < 0 || bitmap > 1024) {\n    throw new Error(\"Invalid bitmap\");\n  }\n  let res = [];\n  for (let i = 0; i < 10; i++) {\n    if ((bitmap & 1 << i) !== 0) {\n      res.push(i);\n    }\n  }\n  return Uint8Array.from(res);\n}\nexport { MAX_SIGNER_IN_MULTISIG, MIN_SIGNER_IN_MULTISIG, MultiSigPublicKey, parsePartialSignatures };","map":{"version":3,"names":["fromBase64","toBase64","blake2b","bytesToHex","bcs","bytesEqual","PublicKey","SIGNATURE_FLAG_TO_SCHEME","SIGNATURE_SCHEME_TO_FLAG","parseSerializedSignature","normalizeSuiAddress","publicKeyFromRawBytes","toZkLoginPublicIdentifier","MultiSigSigner","MAX_SIGNER_IN_MULTISIG","MIN_SIGNER_IN_MULTISIG","MultiSigPublicKey","constructor","value","options","rawBytes","multisigPublicKey","parse","Uint8Array","serialize","toBytes","threshold","Error","seenPublicKeys","Set","publicKeys","pk_map","map","pubKey","weight","scheme","bytes","Object","entries","filter","name","publicKeyStr","from","toString","has","add","publicKey","totalWeight","reduce","sum","length","fromPublicKeys","flag","Array","toRawBytes","equals","getPublicKeys","getThreshold","getSigner","signers","toSuiAddress","maxLength","tmp","set","u16","i","toSuiBytes","slice","dkLen","verify","message","multisigSignature","parsed","signatureScheme","multisig","signatureWeight","multisig_pk","signature","parsePartialSignatures","combinePartialSignatures","signatures","bitmap","compressedSignatures","zkLogin","addressSeed","iss","x","Number","publicKeyIndex","j","sigs","MultiSig","maxSize","res","pkIndex","asIndices","at","pair","pkBytes","values","push"],"sources":["/home/cala/project/bridgeweb/node_modules/@suiet/wallet-kit/node_modules/@mysten/sui/src/multisig/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Signer } from '../cryptography/keypair.js';\nimport { bytesEqual, PublicKey } from '../cryptography/publickey.js';\nimport {\n\tSIGNATURE_FLAG_TO_SCHEME,\n\tSIGNATURE_SCHEME_TO_FLAG,\n} from '../cryptography/signature-scheme.js';\nimport type { SignatureFlag, SignatureScheme } from '../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../cryptography/signature.js';\nimport type { SuiGraphQLClient } from '../graphql/client.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\n// eslint-disable-next-line import/no-cycle\nimport { publicKeyFromRawBytes } from '../verify/index.js';\nimport { toZkLoginPublicIdentifier } from '../zklogin/publickey.js';\nimport { MultiSigSigner } from './signer.js';\n\ntype CompressedSignature =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] }\n\t| { ZkLogin: number[] };\n\ntype PublicKeyEnum =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] }\n\t| { ZkLogin: number[] };\n\ntype PubkeyEnumWeightPair = {\n\tpubKey: PublicKeyEnum;\n\tweight: number;\n};\n\ntype MultiSigPublicKeyStruct = {\n\tpk_map: PubkeyEnumWeightPair[];\n\tthreshold: number;\n};\n\nexport type MultiSigStruct = {\n\tsigs: CompressedSignature[];\n\tbitmap: number;\n\tmultisig_pk: MultiSigPublicKeyStruct;\n};\n\ntype ParsedPartialMultiSigSignature = {\n\tsignatureScheme: SignatureScheme;\n\tsignature: Uint8Array;\n\tpublicKey: PublicKey;\n\tweight: number;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\nexport const MIN_SIGNER_IN_MULTISIG = 1;\n/**\n * A MultiSig public key\n */\nexport class MultiSigPublicKey extends PublicKey {\n\tprivate rawBytes: Uint8Array;\n\tprivate multisigPublicKey: MultiSigPublicKeyStruct;\n\tprivate publicKeys: {\n\t\tweight: number;\n\t\tpublicKey: PublicKey;\n\t}[];\n\t/**\n\t * Create a new MultiSigPublicKey object\n\t */\n\tconstructor(\n\t\t/**\n\t\t *  MultiSig public key as buffer or base-64 encoded string\n\t\t */\n\t\tvalue: string | Uint8Array | MultiSigPublicKeyStruct,\n\t\toptions: { client?: SuiGraphQLClient } = {},\n\t) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.rawBytes = fromBase64(value);\n\n\t\t\tthis.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.rawBytes = value;\n\t\t\tthis.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n\t\t} else {\n\t\t\tthis.multisigPublicKey = value;\n\t\t\tthis.rawBytes = bcs.MultiSigPublicKey.serialize(value).toBytes();\n\t\t}\n\t\tif (this.multisigPublicKey.threshold < 1) {\n\t\t\tthrow new Error('Invalid threshold');\n\t\t}\n\n\t\tconst seenPublicKeys = new Set<string>();\n\n\t\tthis.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {\n\t\t\tconst [scheme, bytes] = Object.entries(pubKey).filter(([name]) => name !== '$kind')[0] as [\n\t\t\t\tSignatureScheme,\n\t\t\t\tnumber[],\n\t\t\t];\n\t\t\tconst publicKeyStr = Uint8Array.from(bytes).toString();\n\n\t\t\tif (seenPublicKeys.has(publicKeyStr)) {\n\t\t\t\tthrow new Error(`Multisig does not support duplicate public keys`);\n\t\t\t}\n\t\t\tseenPublicKeys.add(publicKeyStr);\n\n\t\t\tif (weight < 1) {\n\t\t\t\tthrow new Error(`Invalid weight`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpublicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes), options),\n\t\t\t\tweight,\n\t\t\t};\n\t\t});\n\n\t\tconst totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);\n\n\t\tif (this.multisigPublicKey.threshold > totalWeight) {\n\t\t\tthrow new Error(`Unreachable threshold`);\n\t\t}\n\n\t\tif (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\n\t\tif (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);\n\t\t}\n\t}\n\t/**\n\t * \tA static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.\n\t */\n\n\tstatic fromPublicKeys({\n\t\tthreshold,\n\t\tpublicKeys,\n\t}: {\n\t\tthreshold: number;\n\t\tpublicKeys: { publicKey: PublicKey; weight: number }[];\n\t}) {\n\t\treturn new MultiSigPublicKey({\n\t\t\tpk_map: publicKeys.map(({ publicKey, weight }) => {\n\t\t\t\tconst scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag() as SignatureFlag];\n\n\t\t\t\treturn {\n\t\t\t\t\tpubKey: { [scheme]: Array.from(publicKey.toRawBytes()) } as PublicKeyEnum,\n\t\t\t\t\tweight,\n\t\t\t\t};\n\t\t\t}),\n\t\t\tthreshold,\n\t\t});\n\t}\n\n\t/**\n\t * Checks if two MultiSig public keys are equal\n\t */\n\toverride equals(publicKey: MultiSigPublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the MultiSig public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.rawBytes;\n\t}\n\n\tgetPublicKeys() {\n\t\treturn this.publicKeys;\n\t}\n\n\tgetThreshold() {\n\t\treturn this.multisigPublicKey.threshold;\n\t}\n\n\tgetSigner(...signers: [signer: Signer]) {\n\t\treturn new MultiSigSigner(this, signers);\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\toverride toSuiAddress(): string {\n\t\t// max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n\t\tconst maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n\t\tconst tmp = new Uint8Array(maxLength);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n\t\ttmp.set(bcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);\n\t\t// The initial value 3 ensures that following data will be after the flag byte and threshold bytes\n\t\tlet i = 3;\n\t\tfor (const { publicKey, weight } of this.publicKeys) {\n\t\t\tconst bytes = publicKey.toSuiBytes();\n\t\t\ttmp.set(bytes, i);\n\t\t\ti += bytes.length;\n\t\t\ttmp.set([weight], i++);\n\t\t}\n\t\treturn normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n\t}\n\n\t/**\n\t * Return the Sui address associated with this MultiSig public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['MultiSig'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, multisigSignature: string): Promise<boolean> {\n\t\t// Multisig verification only supports serialized signature\n\t\tconst parsed = parseSerializedSignature(multisigSignature);\n\n\t\tif (parsed.signatureScheme !== 'MultiSig') {\n\t\t\tthrow new Error('Invalid signature scheme');\n\t\t}\n\n\t\tconst { multisig } = parsed;\n\n\t\tlet signatureWeight = 0;\n\n\t\tif (\n\t\t\t!bytesEqual(\n\t\t\t\tbcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),\n\t\t\t\tbcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes(),\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {\n\t\t\tif (!(await publicKey.verify(message, signature))) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsignatureWeight += weight;\n\t\t}\n\n\t\treturn signatureWeight >= this.multisigPublicKey.threshold;\n\t}\n\n\t/**\n\t * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once\n\t * and that all the public keys involved are known and valid, and then serializes multisig into the standard format\n\t */\n\tcombinePartialSignatures(signatures: string[]): string {\n\t\tif (signatures.length > MAX_SIGNER_IN_MULTISIG) {\n\t\t\tthrow new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t\t}\n\n\t\tlet bitmap = 0;\n\t\tconst compressedSignatures: CompressedSignature[] = new Array(signatures.length);\n\n\t\tfor (let i = 0; i < signatures.length; i++) {\n\t\t\tlet parsed = parseSerializedSignature(signatures[i]);\n\t\t\tif (parsed.signatureScheme === 'MultiSig') {\n\t\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t\t}\n\n\t\t\tlet publicKey;\n\t\t\tif (parsed.signatureScheme === 'ZkLogin') {\n\t\t\t\tpublicKey = toZkLoginPublicIdentifier(\n\t\t\t\t\tparsed.zkLogin?.addressSeed,\n\t\t\t\t\tparsed.zkLogin?.iss,\n\t\t\t\t).toRawBytes();\n\t\t\t} else {\n\t\t\t\tpublicKey = parsed.publicKey;\n\t\t\t}\n\n\t\t\tcompressedSignatures[i] = {\n\t\t\t\t[parsed.signatureScheme]: Array.from(parsed.signature.map((x: number) => Number(x))),\n\t\t\t} as CompressedSignature;\n\n\t\t\tlet publicKeyIndex;\n\t\t\tfor (let j = 0; j < this.publicKeys.length; j++) {\n\t\t\t\tif (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {\n\t\t\t\t\tif (bitmap & (1 << j)) {\n\t\t\t\t\t\tthrow new Error('Received multiple signatures from the same public key');\n\t\t\t\t\t}\n\n\t\t\t\t\tpublicKeyIndex = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (publicKeyIndex === undefined) {\n\t\t\t\tthrow new Error('Received signature from unknown public key');\n\t\t\t}\n\n\t\t\tbitmap |= 1 << publicKeyIndex;\n\t\t}\n\n\t\tlet multisig: MultiSigStruct = {\n\t\t\tsigs: compressedSignatures,\n\t\t\tbitmap,\n\t\t\tmultisig_pk: this.multisigPublicKey,\n\t\t};\n\t\tconst bytes = bcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();\n\t\tlet tmp = new Uint8Array(bytes.length + 1);\n\t\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\t\ttmp.set(bytes, 1);\n\t\treturn toBase64(tmp);\n\t}\n}\n\n/**\n * Parse multisig structure into an array of individual signatures: signature scheme, the actual individual signature, public key and its weight.\n */\nexport function parsePartialSignatures(\n\tmultisig: MultiSigStruct,\n\toptions: { client?: SuiGraphQLClient } = {},\n): ParsedPartialMultiSigSignature[] {\n\tlet res: ParsedPartialMultiSigSignature[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tconst [signatureScheme, signature] = Object.entries(multisig.sigs[i]).filter(\n\t\t\t([name]) => name !== '$kind',\n\t\t)[0] as [SignatureScheme, number[]];\n\t\tconst pkIndex = asIndices(multisig.bitmap).at(i)!;\n\t\tconst pair = multisig.multisig_pk.pk_map[pkIndex];\n\t\tconst pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);\n\n\t\tif (signatureScheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tconst publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes, options);\n\n\t\tres[i] = {\n\t\t\tsignatureScheme,\n\t\t\tsignature: Uint8Array.from(signature),\n\t\t\tpublicKey: publicKey,\n\t\t\tweight: pair.weight,\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction asIndices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tlet res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}