{"ast":null,"code":"var e = {\n  NAME: \"Name\",\n  DOCUMENT: \"Document\",\n  OPERATION_DEFINITION: \"OperationDefinition\",\n  VARIABLE_DEFINITION: \"VariableDefinition\",\n  SELECTION_SET: \"SelectionSet\",\n  FIELD: \"Field\",\n  ARGUMENT: \"Argument\",\n  FRAGMENT_SPREAD: \"FragmentSpread\",\n  INLINE_FRAGMENT: \"InlineFragment\",\n  FRAGMENT_DEFINITION: \"FragmentDefinition\",\n  VARIABLE: \"Variable\",\n  INT: \"IntValue\",\n  FLOAT: \"FloatValue\",\n  STRING: \"StringValue\",\n  BOOLEAN: \"BooleanValue\",\n  NULL: \"NullValue\",\n  ENUM: \"EnumValue\",\n  LIST: \"ListValue\",\n  OBJECT: \"ObjectValue\",\n  OBJECT_FIELD: \"ObjectField\",\n  DIRECTIVE: \"Directive\",\n  NAMED_TYPE: \"NamedType\",\n  LIST_TYPE: \"ListType\",\n  NON_NULL_TYPE: \"NonNullType\"\n};\nvar r = {\n  QUERY: \"query\",\n  MUTATION: \"mutation\",\n  SUBSCRIPTION: \"subscription\"\n};\nclass GraphQLError extends Error {\n  constructor(e, r, n, i, t, a, l) {\n    super(e);\n    this.name = \"GraphQLError\";\n    this.message = e;\n    if (t) {\n      this.path = t;\n    }\n    if (r) {\n      this.nodes = Array.isArray(r) ? r : [r];\n    }\n    if (n) {\n      this.source = n;\n    }\n    if (i) {\n      this.positions = i;\n    }\n    if (a) {\n      this.originalError = a;\n    }\n    var o = l;\n    if (!o && a) {\n      var u = a.extensions;\n      if (u && \"object\" == typeof u) {\n        o = u;\n      }\n    }\n    this.extensions = o || {};\n  }\n  toJSON() {\n    return {\n      ...this,\n      message: this.message\n    };\n  }\n  toString() {\n    return this.message;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n}\nvar n;\nvar i;\nfunction error(e) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${i} in ${e}`);\n}\nfunction advance(e) {\n  e.lastIndex = i;\n  if (e.test(n)) {\n    return n.slice(i, i = e.lastIndex);\n  }\n}\nvar t = / +(?=[^\\s])/y;\nfunction blockString(e) {\n  var r = e.split(\"\\n\");\n  var n = \"\";\n  var i = 0;\n  var a = 0;\n  var l = r.length - 1;\n  for (var o = 0; o < r.length; o++) {\n    t.lastIndex = 0;\n    if (t.test(r[o])) {\n      if (o && (!i || t.lastIndex < i)) {\n        i = t.lastIndex;\n      }\n      a = a || o;\n      l = o;\n    }\n  }\n  for (var u = a; u <= l; u++) {\n    if (u !== a) {\n      n += \"\\n\";\n    }\n    n += r[u].slice(i).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return n;\n}\nfunction ignored() {\n  for (var e = 0 | n.charCodeAt(i++); 9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e; e = 0 | n.charCodeAt(i++)) {\n    if (35 === e) {\n      while (10 !== (e = n.charCodeAt(i++)) && 13 !== e) {}\n    }\n  }\n  i--;\n}\nvar a = /[_A-Za-z]\\w*/y;\nvar l = new RegExp(\"(?:(null|true|false)|\\\\$(\" + a.source + ')|(-?\\\\d+)((?:\\\\.\\\\d+)?[eE][+-]?\\\\d+|\\\\.\\\\d+)?|(\"\"\"(?:\"\"\"|(?:[\\\\s\\\\S]*?[^\\\\\\\\])\"\"\"))|(\"(?:\"|[^\\\\r\\\\n]*?[^\\\\\\\\]\"))|(' + a.source + \"))\", \"y\");\nvar o = function (e) {\n  e[e.Const = 1] = \"Const\";\n  e[e.Var = 2] = \"Var\";\n  e[e.Int = 3] = \"Int\";\n  e[e.Float = 4] = \"Float\";\n  e[e.BlockString = 5] = \"BlockString\";\n  e[e.String = 6] = \"String\";\n  e[e.Enum = 7] = \"Enum\";\n  return e;\n}(o || {});\nvar u = /\\\\/;\nfunction value(e) {\n  var r;\n  var t;\n  l.lastIndex = i;\n  if (91 === n.charCodeAt(i)) {\n    i++;\n    ignored();\n    var d = [];\n    while (93 !== n.charCodeAt(i)) {\n      d.push(value(e));\n    }\n    i++;\n    ignored();\n    return {\n      kind: \"ListValue\",\n      values: d\n    };\n  } else if (123 === n.charCodeAt(i)) {\n    i++;\n    ignored();\n    var s = [];\n    while (125 !== n.charCodeAt(i)) {\n      if (null == (r = advance(a))) {\n        throw error(\"ObjectField\");\n      }\n      ignored();\n      if (58 !== n.charCodeAt(i++)) {\n        throw error(\"ObjectField\");\n      }\n      ignored();\n      s.push({\n        kind: \"ObjectField\",\n        name: {\n          kind: \"Name\",\n          value: r\n        },\n        value: value(e)\n      });\n    }\n    i++;\n    ignored();\n    return {\n      kind: \"ObjectValue\",\n      fields: s\n    };\n  } else if (null != (t = l.exec(n))) {\n    i = l.lastIndex;\n    ignored();\n    if (null != (r = t[o.Const])) {\n      return \"null\" === r ? {\n        kind: \"NullValue\"\n      } : {\n        kind: \"BooleanValue\",\n        value: \"true\" === r\n      };\n    } else if (null != (r = t[o.Var])) {\n      if (e) {\n        throw error(\"Variable\");\n      } else {\n        return {\n          kind: \"Variable\",\n          name: {\n            kind: \"Name\",\n            value: r\n          }\n        };\n      }\n    } else if (null != (r = t[o.Int])) {\n      var v;\n      if (null != (v = t[o.Float])) {\n        return {\n          kind: \"FloatValue\",\n          value: r + v\n        };\n      } else {\n        return {\n          kind: \"IntValue\",\n          value: r\n        };\n      }\n    } else if (null != (r = t[o.BlockString])) {\n      return {\n        kind: \"StringValue\",\n        value: blockString(r.slice(3, -3)),\n        block: !0\n      };\n    } else if (null != (r = t[o.String])) {\n      return {\n        kind: \"StringValue\",\n        value: u.test(r) ? JSON.parse(r) : r.slice(1, -1),\n        block: !1\n      };\n    } else if (null != (r = t[o.Enum])) {\n      return {\n        kind: \"EnumValue\",\n        value: r\n      };\n    }\n  }\n  throw error(\"Value\");\n}\nfunction arguments_(e) {\n  if (40 === n.charCodeAt(i)) {\n    var r = [];\n    i++;\n    ignored();\n    var t;\n    do {\n      if (null == (t = advance(a))) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      if (58 !== n.charCodeAt(i++)) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      r.push({\n        kind: \"Argument\",\n        name: {\n          kind: \"Name\",\n          value: t\n        },\n        value: value(e)\n      });\n    } while (41 !== n.charCodeAt(i));\n    i++;\n    ignored();\n    return r;\n  }\n}\nfunction directives(e) {\n  if (64 === n.charCodeAt(i)) {\n    var r = [];\n    var t;\n    do {\n      i++;\n      if (null == (t = advance(a))) {\n        throw error(\"Directive\");\n      }\n      ignored();\n      r.push({\n        kind: \"Directive\",\n        name: {\n          kind: \"Name\",\n          value: t\n        },\n        arguments: arguments_(e)\n      });\n    } while (64 === n.charCodeAt(i));\n    return r;\n  }\n}\nfunction type() {\n  var e;\n  var r = 0;\n  while (91 === n.charCodeAt(i)) {\n    r++;\n    i++;\n    ignored();\n  }\n  if (null == (e = advance(a))) {\n    throw error(\"NamedType\");\n  }\n  ignored();\n  var t = {\n    kind: \"NamedType\",\n    name: {\n      kind: \"Name\",\n      value: e\n    }\n  };\n  do {\n    if (33 === n.charCodeAt(i)) {\n      i++;\n      ignored();\n      t = {\n        kind: \"NonNullType\",\n        type: t\n      };\n    }\n    if (r) {\n      if (93 !== n.charCodeAt(i++)) {\n        throw error(\"NamedType\");\n      }\n      ignored();\n      t = {\n        kind: \"ListType\",\n        type: t\n      };\n    }\n  } while (r--);\n  return t;\n}\nvar d = new RegExp(\"(?:(\\\\.{3})|(\" + a.source + \"))\", \"y\");\nvar s = function (e) {\n  e[e.Spread = 1] = \"Spread\";\n  e[e.Name = 2] = \"Name\";\n  return e;\n}(s || {});\nfunction selectionSet() {\n  var e = [];\n  var r;\n  var t;\n  do {\n    d.lastIndex = i;\n    if (null != (t = d.exec(n))) {\n      i = d.lastIndex;\n      if (null != t[s.Spread]) {\n        ignored();\n        var l = advance(a);\n        if (null != l && \"on\" !== l) {\n          ignored();\n          e.push({\n            kind: \"FragmentSpread\",\n            name: {\n              kind: \"Name\",\n              value: l\n            },\n            directives: directives(!1)\n          });\n        } else {\n          ignored();\n          if (\"on\" === l) {\n            if (null == (l = advance(a))) {\n              throw error(\"NamedType\");\n            }\n            ignored();\n          }\n          var o = directives(!1);\n          if (123 !== n.charCodeAt(i++)) {\n            throw error(\"InlineFragment\");\n          }\n          ignored();\n          e.push({\n            kind: \"InlineFragment\",\n            typeCondition: l ? {\n              kind: \"NamedType\",\n              name: {\n                kind: \"Name\",\n                value: l\n              }\n            } : void 0,\n            directives: o,\n            selectionSet: selectionSet()\n          });\n        }\n      } else if (null != (r = t[s.Name])) {\n        var u = void 0;\n        ignored();\n        if (58 === n.charCodeAt(i)) {\n          i++;\n          ignored();\n          u = r;\n          if (null == (r = advance(a))) {\n            throw error(\"Field\");\n          }\n          ignored();\n        }\n        var v = arguments_(!1);\n        ignored();\n        var c = directives(!1);\n        var f = void 0;\n        if (123 === n.charCodeAt(i)) {\n          i++;\n          ignored();\n          f = selectionSet();\n        }\n        e.push({\n          kind: \"Field\",\n          alias: u ? {\n            kind: \"Name\",\n            value: u\n          } : void 0,\n          name: {\n            kind: \"Name\",\n            value: r\n          },\n          arguments: v,\n          directives: c,\n          selectionSet: f\n        });\n      }\n    } else {\n      throw error(\"SelectionSet\");\n    }\n  } while (125 !== n.charCodeAt(i));\n  i++;\n  ignored();\n  return {\n    kind: \"SelectionSet\",\n    selections: e\n  };\n}\nfunction fragmentDefinition() {\n  var e;\n  var r;\n  if (null == (e = advance(a))) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  if (\"on\" !== advance(a)) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  if (null == (r = advance(a))) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  var t = directives(!1);\n  if (123 !== n.charCodeAt(i++)) {\n    throw error(\"FragmentDefinition\");\n  }\n  ignored();\n  return {\n    kind: \"FragmentDefinition\",\n    name: {\n      kind: \"Name\",\n      value: e\n    },\n    typeCondition: {\n      kind: \"NamedType\",\n      name: {\n        kind: \"Name\",\n        value: r\n      }\n    },\n    directives: t,\n    selectionSet: selectionSet()\n  };\n}\nvar v = /(?:query|mutation|subscription|fragment)/y;\nfunction operationDefinition(e) {\n  var r;\n  var t;\n  var l;\n  if (e) {\n    ignored();\n    r = advance(a);\n    t = function variableDefinitions() {\n      ignored();\n      if (40 === n.charCodeAt(i)) {\n        var e = [];\n        i++;\n        ignored();\n        var r;\n        do {\n          if (36 !== n.charCodeAt(i++)) {\n            throw error(\"Variable\");\n          }\n          if (null == (r = advance(a))) {\n            throw error(\"Variable\");\n          }\n          ignored();\n          if (58 !== n.charCodeAt(i++)) {\n            throw error(\"VariableDefinition\");\n          }\n          ignored();\n          var t = type();\n          var l = void 0;\n          if (61 === n.charCodeAt(i)) {\n            i++;\n            ignored();\n            l = value(!0);\n          }\n          ignored();\n          e.push({\n            kind: \"VariableDefinition\",\n            variable: {\n              kind: \"Variable\",\n              name: {\n                kind: \"Name\",\n                value: r\n              }\n            },\n            type: t,\n            defaultValue: l,\n            directives: directives(!0)\n          });\n        } while (41 !== n.charCodeAt(i));\n        i++;\n        ignored();\n        return e;\n      }\n    }();\n    l = directives(!1);\n  }\n  if (123 === n.charCodeAt(i)) {\n    i++;\n    ignored();\n    return {\n      kind: \"OperationDefinition\",\n      operation: e || \"query\",\n      name: r ? {\n        kind: \"Name\",\n        value: r\n      } : void 0,\n      variableDefinitions: t,\n      directives: l,\n      selectionSet: selectionSet()\n    };\n  }\n}\nfunction parse(e, r) {\n  i = 0;\n  return function document(e, r) {\n    var n;\n    var t;\n    ignored();\n    var a = [];\n    do {\n      if (\"fragment\" === (n = advance(v))) {\n        ignored();\n        a.push(fragmentDefinition());\n      } else if (null != (t = operationDefinition(n))) {\n        a.push(t);\n      } else {\n        throw error(\"Document\");\n      }\n    } while (i < e.length);\n    if (!r) {\n      var l;\n      return {\n        kind: \"Document\",\n        definitions: a,\n        set loc(e) {\n          l = e;\n        },\n        get loc() {\n          if (!l) {\n            l = {\n              start: 0,\n              end: e.length,\n              startToken: void 0,\n              endToken: void 0,\n              source: {\n                body: e,\n                name: \"graphql.web\",\n                locationOffset: {\n                  line: 1,\n                  column: 1\n                }\n              }\n            };\n          }\n          return l;\n        }\n      };\n    }\n    return {\n      kind: \"Document\",\n      definitions: a\n    };\n  }(n = \"string\" == typeof e.body ? e.body : e, r && r.noLocation);\n}\nfunction parseValue(e, r) {\n  n = \"string\" == typeof e.body ? e.body : e;\n  i = 0;\n  ignored();\n  return value(!1);\n}\nfunction parseType(e, r) {\n  n = \"string\" == typeof e.body ? e.body : e;\n  i = 0;\n  return type();\n}\nvar c = {};\nfunction visit(e, r) {\n  var n = [];\n  var i = [];\n  try {\n    var t = function traverse(e, t, a) {\n      var l = !1;\n      var o = r[e.kind] && r[e.kind].enter || r[e.kind] || r.enter;\n      var u = o && o.call(r, e, t, a, i, n);\n      if (!1 === u) {\n        return e;\n      } else if (null === u) {\n        return null;\n      } else if (u === c) {\n        throw c;\n      } else if (u && \"string\" == typeof u.kind) {\n        l = u !== e;\n        e = u;\n      }\n      if (a) {\n        n.push(a);\n      }\n      var d;\n      var s = {\n        ...e\n      };\n      for (var v in e) {\n        i.push(v);\n        var f = e[v];\n        if (Array.isArray(f)) {\n          var g = [];\n          for (var m = 0; m < f.length; m++) {\n            if (null != f[m] && \"string\" == typeof f[m].kind) {\n              n.push(e);\n              i.push(m);\n              d = traverse(f[m], m, f);\n              i.pop();\n              n.pop();\n              if (null == d) {\n                l = !0;\n              } else {\n                l = l || d !== f[m];\n                g.push(d);\n              }\n            }\n          }\n          f = g;\n        } else if (null != f && \"string\" == typeof f.kind) {\n          if (void 0 !== (d = traverse(f, v, e))) {\n            l = l || f !== d;\n            f = d;\n          }\n        }\n        i.pop();\n        if (l) {\n          s[v] = f;\n        }\n      }\n      if (a) {\n        n.pop();\n      }\n      var p = r[e.kind] && r[e.kind].leave || r.leave;\n      var h = p && p.call(r, e, t, a, i, n);\n      if (h === c) {\n        throw c;\n      } else if (void 0 !== h) {\n        return h;\n      } else if (void 0 !== u) {\n        return l ? s : u;\n      } else {\n        return l ? s : e;\n      }\n    }(e);\n    return void 0 !== t && !1 !== t ? t : e;\n  } catch (r) {\n    if (r !== c) {\n      throw r;\n    }\n    return e;\n  }\n}\nfunction mapJoin(e, r, n) {\n  var i = \"\";\n  for (var t = 0; t < e.length; t++) {\n    if (t) {\n      i += r;\n    }\n    i += n(e[t]);\n  }\n  return i;\n}\nfunction printString(e) {\n  return JSON.stringify(e);\n}\nfunction printBlockString(e) {\n  return '\"\"\"\\n' + e.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\nvar f = \"\\n\";\nvar g = {\n  OperationDefinition(e) {\n    var r = e.operation;\n    if (e.name) {\n      r += \" \" + e.name.value;\n    }\n    if (e.variableDefinitions && e.variableDefinitions.length) {\n      if (!e.name) {\n        r += \" \";\n      }\n      r += \"(\" + mapJoin(e.variableDefinitions, \", \", g.VariableDefinition) + \")\";\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", g.Directive);\n    }\n    return \"query\" !== r ? r + \" \" + g.SelectionSet(e.selectionSet) : g.SelectionSet(e.selectionSet);\n  },\n  VariableDefinition(e) {\n    var r = g.Variable(e.variable) + \": \" + _print(e.type);\n    if (e.defaultValue) {\n      r += \" = \" + _print(e.defaultValue);\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", g.Directive);\n    }\n    return r;\n  },\n  Field(e) {\n    var r = e.alias ? e.alias.value + \": \" + e.name.value : e.name.value;\n    if (e.arguments && e.arguments.length) {\n      var n = mapJoin(e.arguments, \", \", g.Argument);\n      if (r.length + n.length + 2 > 80) {\n        r += \"(\" + (f += \"  \") + mapJoin(e.arguments, f, g.Argument) + (f = f.slice(0, -2)) + \")\";\n      } else {\n        r += \"(\" + n + \")\";\n      }\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", g.Directive);\n    }\n    if (e.selectionSet && e.selectionSet.selections.length) {\n      r += \" \" + g.SelectionSet(e.selectionSet);\n    }\n    return r;\n  },\n  StringValue(e) {\n    if (e.block) {\n      return printBlockString(e.value).replace(/\\n/g, f);\n    } else {\n      return printString(e.value);\n    }\n  },\n  BooleanValue: e => \"\" + e.value,\n  NullValue: e => \"null\",\n  IntValue: e => e.value,\n  FloatValue: e => e.value,\n  EnumValue: e => e.value,\n  Name: e => e.value,\n  Variable: e => \"$\" + e.name.value,\n  ListValue: e => \"[\" + mapJoin(e.values, \", \", _print) + \"]\",\n  ObjectValue: e => \"{\" + mapJoin(e.fields, \", \", g.ObjectField) + \"}\",\n  ObjectField: e => e.name.value + \": \" + _print(e.value),\n  Document(e) {\n    if (!e.definitions || !e.definitions.length) {\n      return \"\";\n    }\n    return mapJoin(e.definitions, \"\\n\\n\", _print);\n  },\n  SelectionSet: e => \"{\" + (f += \"  \") + mapJoin(e.selections, f, _print) + (f = f.slice(0, -2)) + \"}\",\n  Argument: e => e.name.value + \": \" + _print(e.value),\n  FragmentSpread(e) {\n    var r = \"...\" + e.name.value;\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", g.Directive);\n    }\n    return r;\n  },\n  InlineFragment(e) {\n    var r = \"...\";\n    if (e.typeCondition) {\n      r += \" on \" + e.typeCondition.name.value;\n    }\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", g.Directive);\n    }\n    return r += \" \" + g.SelectionSet(e.selectionSet);\n  },\n  FragmentDefinition(e) {\n    var r = \"fragment \" + e.name.value;\n    r += \" on \" + e.typeCondition.name.value;\n    if (e.directives && e.directives.length) {\n      r += \" \" + mapJoin(e.directives, \" \", g.Directive);\n    }\n    return r + \" \" + g.SelectionSet(e.selectionSet);\n  },\n  Directive(e) {\n    var r = \"@\" + e.name.value;\n    if (e.arguments && e.arguments.length) {\n      r += \"(\" + mapJoin(e.arguments, \", \", g.Argument) + \")\";\n    }\n    return r;\n  },\n  NamedType: e => e.name.value,\n  ListType: e => \"[\" + _print(e.type) + \"]\",\n  NonNullType: e => _print(e.type) + \"!\"\n};\nvar _print = e => g[e.kind](e);\nfunction print(e) {\n  f = \"\\n\";\n  return g[e.kind] ? g[e.kind](e) : \"\";\n}\nfunction valueFromASTUntyped(e, r) {\n  switch (e.kind) {\n    case \"NullValue\":\n      return null;\n    case \"IntValue\":\n      return parseInt(e.value, 10);\n    case \"FloatValue\":\n      return parseFloat(e.value);\n    case \"StringValue\":\n    case \"EnumValue\":\n    case \"BooleanValue\":\n      return e.value;\n    case \"ListValue\":\n      var n = [];\n      for (var i = 0, t = e.values.length; i < t; i++) {\n        n.push(valueFromASTUntyped(e.values[i], r));\n      }\n      return n;\n    case \"ObjectValue\":\n      var a = Object.create(null);\n      for (var l = 0, o = e.fields.length; l < o; l++) {\n        var u = e.fields[l];\n        a[u.name.value] = valueFromASTUntyped(u.value, r);\n      }\n      return a;\n    case \"Variable\":\n      return r && r[e.name.value];\n  }\n}\nfunction valueFromTypeNode(e, r, n) {\n  if (\"Variable\" === e.kind) {\n    return n ? valueFromTypeNode(n[e.name.value], r, n) : void 0;\n  } else if (\"NonNullType\" === r.kind) {\n    return \"NullValue\" !== e.kind ? valueFromTypeNode(e, r, n) : void 0;\n  } else if (\"NullValue\" === e.kind) {\n    return null;\n  } else if (\"ListType\" === r.kind) {\n    if (\"ListValue\" === e.kind) {\n      var i = [];\n      for (var t = 0, a = e.values.length; t < a; t++) {\n        var l = valueFromTypeNode(e.values[t], r.type, n);\n        if (void 0 === l) {\n          return;\n        } else {\n          i.push(l);\n        }\n      }\n      return i;\n    }\n  } else if (\"NamedType\" === r.kind) {\n    switch (r.name.value) {\n      case \"Int\":\n      case \"Float\":\n      case \"String\":\n      case \"Bool\":\n        return r.name.value + \"Value\" === e.kind ? valueFromASTUntyped(e, n) : void 0;\n      default:\n        return valueFromASTUntyped(e, n);\n    }\n  }\n}\nfunction isSelectionNode(e) {\n  return \"Field\" === e.kind || \"FragmentSpread\" === e.kind || \"InlineFragment\" === e.kind;\n}\nfunction Source(e, r, n) {\n  return {\n    body: e,\n    name: r,\n    locationOffset: n || {\n      line: 1,\n      column: 1\n    }\n  };\n}\nexport { c as BREAK, GraphQLError, e as Kind, r as OperationTypeNode, Source, isSelectionNode, parse, parseType, parseValue, print, printBlockString, printString, valueFromASTUntyped, valueFromTypeNode, visit };","map":{"version":3,"names":["e","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","r","QUERY","MUTATION","SUBSCRIPTION","GraphQLError","Error","constructor","n","i","t","a","l","name","message","path","nodes","Array","isArray","source","positions","originalError","o","u","extensions","toJSON","toString","Symbol","toStringTag","error","advance","lastIndex","test","slice","blockString","split","length","replace","ignored","charCodeAt","RegExp","Const","Var","Int","Float","BlockString","String","Enum","value","d","push","kind","values","s","fields","exec","v","block","JSON","parse","arguments_","directives","arguments","type","Spread","Name","selectionSet","typeCondition","c","f","alias","selections","fragmentDefinition","operationDefinition","variableDefinitions","variable","defaultValue","operation","document","definitions","loc","start","end","startToken","endToken","body","locationOffset","line","column","noLocation","parseValue","parseType","visit","traverse","enter","call","g","m","pop","p","leave","h","mapJoin","printString","stringify","printBlockString","OperationDefinition","VariableDefinition","Directive","SelectionSet","Variable","_print","Field","Argument","StringValue","BooleanValue","NullValue","IntValue","FloatValue","EnumValue","ListValue","ObjectValue","ObjectField","Document","FragmentSpread","InlineFragment","FragmentDefinition","NamedType","ListType","NonNullType","print","valueFromASTUntyped","parseInt","parseFloat","Object","create","valueFromTypeNode","isSelectionNode","Source"],"sources":["/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/kind.js","/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/error.ts","/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/parser.ts","/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/visitor.ts","/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/printer.ts","/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/values.ts","/home/cala/project/bridgeweb/node_modules/@0no-co/graphql.web/src/helpers.ts"],"sourcesContent":["export const Kind = {\n  NAME: 'Name',\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  DIRECTIVE: 'Directive',\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n\n  /*\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',\n  */\n};\n\nexport const OperationTypeNode = {\n  QUERY: 'query',\n  MUTATION: 'mutation',\n  SUBSCRIPTION: 'subscription',\n};\n","import type { Maybe, Extensions, Source } from './types';\nimport type { ASTNode } from './ast';\n\nexport class GraphQLError extends Error {\n  readonly locations: ReadonlyArray<any> | undefined;\n  readonly path: ReadonlyArray<string | number> | undefined;\n  readonly nodes: ReadonlyArray<any> | undefined;\n  readonly source: Source | undefined;\n  readonly positions: ReadonlyArray<number> | undefined;\n  readonly originalError: Error | undefined;\n  readonly extensions: Extensions;\n\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<Error>,\n    extensions?: Maybe<Extensions>\n  ) {\n    super(message);\n\n    this.name = 'GraphQLError';\n    this.message = message;\n\n    if (path) this.path = path;\n    if (nodes) this.nodes = (Array.isArray(nodes) ? nodes : [nodes]) as ASTNode[];\n    if (source) this.source = source;\n    if (positions) this.positions = positions;\n    if (originalError) this.originalError = originalError;\n\n    let _extensions = extensions;\n    if (!_extensions && originalError) {\n      const originalExtensions = (originalError as any).extensions;\n      if (originalExtensions && typeof originalExtensions === 'object') {\n        _extensions = originalExtensions;\n      }\n    }\n\n    this.extensions = _extensions || {};\n  }\n\n  toJSON(): any {\n    return { ...this, message: this.message };\n  }\n\n  toString(): string {\n    return this.message;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return 'GraphQLError';\n  }\n}\n","/**\n * This is a spec-compliant implementation of a GraphQL query language parser,\n * up-to-date with the October 2021 Edition. Unlike the reference implementation\n * in graphql.js it will only parse the query language, but not the schema\n * language.\n */\nimport type { Kind, OperationTypeNode } from './kind';\nimport { GraphQLError } from './error';\nimport type { Location, Source } from './types';\nimport type * as ast from './ast';\n\nlet input: string;\nlet idx: number;\n\nfunction error(kind: string) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${idx} in ${kind}`);\n}\n\nfunction advance(pattern: RegExp) {\n  pattern.lastIndex = idx;\n  if (pattern.test(input)) {\n    const match = input.slice(idx, (idx = pattern.lastIndex));\n    return match;\n  }\n}\n\nconst leadingRe = / +(?=[^\\s])/y;\nfunction blockString(string: string) {\n  const lines = string.split('\\n');\n  let out = '';\n  let commonIndent = 0;\n  let firstNonEmptyLine = 0;\n  let lastNonEmptyLine = lines.length - 1;\n  for (let i = 0; i < lines.length; i++) {\n    leadingRe.lastIndex = 0;\n    if (leadingRe.test(lines[i])) {\n      if (i && (!commonIndent || leadingRe.lastIndex < commonIndent))\n        commonIndent = leadingRe.lastIndex;\n      firstNonEmptyLine = firstNonEmptyLine || i;\n      lastNonEmptyLine = i;\n    }\n  }\n  for (let i = firstNonEmptyLine; i <= lastNonEmptyLine; i++) {\n    if (i !== firstNonEmptyLine) out += '\\n';\n    out += lines[i].slice(commonIndent).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return out;\n}\n\n// Note: This is equivalent to: /(?:[\\s,]*|#[^\\n\\r]*)*/y\nfunction ignored() {\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    char === 9 /*'\\t'*/ ||\n    char === 10 /*'\\n'*/ ||\n    char === 13 /*'\\r'*/ ||\n    char === 32 /*' '*/ ||\n    char === 35 /*'#'*/ ||\n    char === 44 /*','*/ ||\n    char === 65279 /*'\\ufeff'*/;\n    char = input.charCodeAt(idx++) | 0\n  ) {\n    if (char === 35 /*'#'*/) while ((char = input.charCodeAt(idx++)) !== 10 && char !== 13);\n  }\n  idx--;\n}\n\nconst nameRe = /[_A-Za-z]\\w*/y;\n\n// NOTE: This should be compressed by our build step\n// This merges all possible value parsing into one regular expression\nconst valueRe = new RegExp(\n  '(?:' +\n    // `null`, `true`, and `false` literals (BooleanValue & NullValue)\n    '(null|true|false)|' +\n    // Variables starting with `$` then having a name (VariableNode)\n    '\\\\$(' +\n    nameRe.source +\n    ')|' +\n    // Numbers, starting with int then optionally following with a float part (IntValue and FloatValue)\n    '(-?\\\\d+)((?:\\\\.\\\\d+)?[eE][+-]?\\\\d+|\\\\.\\\\d+)?|' +\n    // Block strings starting with `\"\"\"` until the next unescaped `\"\"\"` (StringValue)\n    '(\"\"\"(?:\"\"\"|(?:[\\\\s\\\\S]*?[^\\\\\\\\])\"\"\"))|' +\n    // Strings starting with `\"` must be on one line (StringValue)\n    '(\"(?:\"|[^\\\\r\\\\n]*?[^\\\\\\\\]\"))|' + // string\n    // Enums are simply names except for our literals (EnumValue)\n    '(' +\n    nameRe.source +\n    '))',\n  'y'\n);\n\n// NOTE: Each of the groups above end up in the RegExpExecArray at the specified indices (starting with 1)\nconst enum ValueGroup {\n  Const = 1,\n  Var,\n  Int,\n  Float,\n  BlockString,\n  String,\n  Enum,\n}\n\ntype ValueExec = RegExpExecArray & {\n  [Prop in ValueGroup]: string | undefined;\n};\n\nconst complexStringRe = /\\\\/;\n\nfunction value(constant: true): ast.ConstValueNode;\nfunction value(constant: boolean): ast.ValueNode;\n\nfunction value(constant: boolean): ast.ValueNode {\n  let match: string | undefined;\n  let exec: ValueExec | null;\n  valueRe.lastIndex = idx;\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    // Lists are checked ahead of time with `[` chars\n    idx++;\n    ignored();\n    const values: ast.ValueNode[] = [];\n    while (input.charCodeAt(idx) !== 93 /*']'*/) values.push(value(constant));\n    idx++;\n    ignored();\n    return {\n      kind: 'ListValue' as Kind.LIST,\n      values,\n    };\n  } else if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    // Objects are checked ahead of time with `{` chars\n    idx++;\n    ignored();\n    const fields: ast.ObjectFieldNode[] = [];\n    while (input.charCodeAt(idx) !== 125 /*'}'*/) {\n      if ((match = advance(nameRe)) == null) throw error('ObjectField');\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('ObjectField');\n      ignored();\n      fields.push({\n        kind: 'ObjectField' as Kind.OBJECT_FIELD,\n        name: { kind: 'Name' as Kind.NAME, value: match },\n        value: value(constant),\n      });\n    }\n    idx++;\n    ignored();\n    return {\n      kind: 'ObjectValue' as Kind.OBJECT,\n      fields,\n    };\n  } else if ((exec = valueRe.exec(input) as ValueExec) != null) {\n    // Starting from here, the merged `valueRe` is used\n    idx = valueRe.lastIndex;\n    ignored();\n    if ((match = exec[ValueGroup.Const]) != null) {\n      return match === 'null'\n        ? { kind: 'NullValue' as Kind.NULL }\n        : {\n            kind: 'BooleanValue' as Kind.BOOLEAN,\n            value: match === 'true',\n          };\n    } else if ((match = exec[ValueGroup.Var]) != null) {\n      if (constant) {\n        throw error('Variable');\n      } else {\n        return {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: {\n            kind: 'Name' as Kind.NAME,\n            value: match,\n          },\n        };\n      }\n    } else if ((match = exec[ValueGroup.Int]) != null) {\n      let floatPart: string | undefined;\n      if ((floatPart = exec[ValueGroup.Float]) != null) {\n        return {\n          kind: 'FloatValue' as Kind.FLOAT,\n          value: match + floatPart,\n        };\n      } else {\n        return {\n          kind: 'IntValue' as Kind.INT,\n          value: match,\n        };\n      }\n    } else if ((match = exec[ValueGroup.BlockString]) != null) {\n      return {\n        kind: 'StringValue' as Kind.STRING,\n        value: blockString(match.slice(3, -3)),\n        block: true,\n      };\n    } else if ((match = exec[ValueGroup.String]) != null) {\n      return {\n        kind: 'StringValue' as Kind.STRING,\n        // When strings don't contain escape codes, a simple slice will be enough, otherwise\n        // `JSON.parse` matches GraphQL's string parsing perfectly\n        value: complexStringRe.test(match) ? (JSON.parse(match) as string) : match.slice(1, -1),\n        block: false,\n      };\n    } else if ((match = exec[ValueGroup.Enum]) != null) {\n      return {\n        kind: 'EnumValue' as Kind.ENUM,\n        value: match,\n      };\n    }\n  }\n\n  throw error('Value');\n}\n\nfunction arguments_(constant: boolean): ast.ArgumentNode[] | undefined {\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    const args: ast.ArgumentNode[] = [];\n    idx++;\n    ignored();\n    let _name: string | undefined;\n    do {\n      if ((_name = advance(nameRe)) == null) throw error('Argument');\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('Argument');\n      ignored();\n      args.push({\n        kind: 'Argument' as Kind.ARGUMENT,\n        name: { kind: 'Name' as Kind.NAME, value: _name },\n        value: value(constant),\n      });\n    } while (input.charCodeAt(idx) !== 41 /*')'*/);\n    idx++;\n    ignored();\n    return args;\n  }\n}\n\nfunction directives(constant: true): ast.ConstDirectiveNode[] | undefined;\nfunction directives(constant: boolean): ast.DirectiveNode[] | undefined;\n\nfunction directives(constant: boolean): ast.DirectiveNode[] | undefined {\n  if (input.charCodeAt(idx) === 64 /*'@'*/) {\n    const directives: ast.DirectiveNode[] = [];\n    let _name: string | undefined;\n    do {\n      idx++;\n      if ((_name = advance(nameRe)) == null) throw error('Directive');\n      ignored();\n      directives.push({\n        kind: 'Directive' as Kind.DIRECTIVE,\n        name: { kind: 'Name' as Kind.NAME, value: _name },\n        arguments: arguments_(constant),\n      });\n    } while (input.charCodeAt(idx) === 64 /*'@'*/);\n    return directives;\n  }\n}\n\nfunction type(): ast.TypeNode {\n  let match: string | undefined;\n  let lists = 0;\n  while (input.charCodeAt(idx) === 91 /*'['*/) {\n    lists++;\n    idx++;\n    ignored();\n  }\n  if ((match = advance(nameRe)) == null) throw error('NamedType');\n  ignored();\n  let type: ast.TypeNode = {\n    kind: 'NamedType' as Kind.NAMED_TYPE,\n    name: { kind: 'Name' as Kind.NAME, value: match },\n  };\n  do {\n    if (input.charCodeAt(idx) === 33 /*'!'*/) {\n      idx++;\n      ignored();\n      type = {\n        kind: 'NonNullType' as Kind.NON_NULL_TYPE,\n        type: type as ast.NamedTypeNode | ast.ListTypeNode,\n      } satisfies ast.NonNullTypeNode;\n    }\n    if (lists) {\n      if (input.charCodeAt(idx++) !== 93 /*']'*/) throw error('NamedType');\n      ignored();\n      type = {\n        kind: 'ListType' as Kind.LIST_TYPE,\n        type: type as ast.NamedTypeNode | ast.ListTypeNode,\n      } satisfies ast.ListTypeNode;\n    }\n  } while (lists--);\n  return type;\n}\n\n// NOTE: This should be compressed by our build step\n// This merges the two possible selection parsing branches into one regular expression\nconst selectionRe = new RegExp(\n  '(?:' +\n    // fragment spreads (FragmentSpread or InlineFragment nodes)\n    '(\\\\.{3})|' +\n    // field aliases or names (FieldNode)\n    '(' +\n    nameRe.source +\n    '))',\n  'y'\n);\n\n// NOTE: Each of the groups above end up in the RegExpExecArray at the indices 1&2\nconst enum SelectionGroup {\n  Spread = 1,\n  Name,\n}\n\ntype SelectionExec = RegExpExecArray & {\n  [Prop in SelectionGroup]: string | undefined;\n};\n\nfunction selectionSet(): ast.SelectionSetNode {\n  const selections: ast.SelectionNode[] = [];\n  let match: string | undefined;\n  let exec: SelectionExec | null;\n  do {\n    selectionRe.lastIndex = idx;\n    if ((exec = selectionRe.exec(input) as SelectionExec) != null) {\n      idx = selectionRe.lastIndex;\n      if (exec[SelectionGroup.Spread] != null) {\n        ignored();\n        let match = advance(nameRe);\n        if (match != null && match !== 'on') {\n          // A simple `...Name` spread with optional directives\n          ignored();\n          selections.push({\n            kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n            name: { kind: 'Name' as Kind.NAME, value: match },\n            directives: directives(false),\n          });\n        } else {\n          ignored();\n          if (match === 'on') {\n            // An inline `... on Name` spread; if this doesn't match, the type condition has been omitted\n            if ((match = advance(nameRe)) == null) throw error('NamedType');\n            ignored();\n          }\n          const _directives = directives(false);\n          if (input.charCodeAt(idx++) !== 123 /*'{'*/) throw error('InlineFragment');\n          ignored();\n          selections.push({\n            kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n            typeCondition: match\n              ? {\n                  kind: 'NamedType' as Kind.NAMED_TYPE,\n                  name: { kind: 'Name' as Kind.NAME, value: match },\n                }\n              : undefined,\n            directives: _directives,\n            selectionSet: selectionSet(),\n          });\n        }\n      } else if ((match = exec[SelectionGroup.Name]) != null) {\n        let _alias: string | undefined;\n        ignored();\n        // Parse the optional alias, by reassigning and then getting the name\n        if (input.charCodeAt(idx) === 58 /*':'*/) {\n          idx++;\n          ignored();\n          _alias = match;\n          if ((match = advance(nameRe)) == null) throw error('Field');\n          ignored();\n        }\n        const _arguments = arguments_(false);\n        ignored();\n        const _directives = directives(false);\n        let _selectionSet: ast.SelectionSetNode | undefined;\n        if (input.charCodeAt(idx) === 123 /*'{'*/) {\n          idx++;\n          ignored();\n          _selectionSet = selectionSet();\n        }\n        selections.push({\n          kind: 'Field' as Kind.FIELD,\n          alias: _alias ? { kind: 'Name' as Kind.NAME, value: _alias } : undefined,\n          name: { kind: 'Name' as Kind.NAME, value: match },\n          arguments: _arguments,\n          directives: _directives,\n          selectionSet: _selectionSet,\n        });\n      }\n    } else {\n      throw error('SelectionSet');\n    }\n  } while (input.charCodeAt(idx) !== 125 /*'}'*/);\n  idx++;\n  ignored();\n  return {\n    kind: 'SelectionSet' as Kind.SELECTION_SET,\n    selections,\n  };\n}\n\nfunction variableDefinitions(): ast.VariableDefinitionNode[] | undefined {\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    const vars: ast.VariableDefinitionNode[] = [];\n    idx++;\n    ignored();\n    let _name: string | undefined;\n    do {\n      if (input.charCodeAt(idx++) !== 36 /*'$'*/) throw error('Variable');\n      if ((_name = advance(nameRe)) == null) throw error('Variable');\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('VariableDefinition');\n      ignored();\n      const _type = type();\n      let _defaultValue: ast.ConstValueNode | undefined;\n      if (input.charCodeAt(idx) === 61 /*'='*/) {\n        idx++;\n        ignored();\n        _defaultValue = value(true);\n      }\n      ignored();\n      vars.push({\n        kind: 'VariableDefinition' as Kind.VARIABLE_DEFINITION,\n        variable: {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: { kind: 'Name' as Kind.NAME, value: _name },\n        },\n        type: _type,\n        defaultValue: _defaultValue,\n        directives: directives(true),\n      });\n    } while (input.charCodeAt(idx) !== 41 /*')'*/);\n    idx++;\n    ignored();\n    return vars;\n  }\n}\n\nfunction fragmentDefinition(): ast.FragmentDefinitionNode {\n  let _name: string | undefined;\n  let _condition: string | undefined;\n  if ((_name = advance(nameRe)) == null) throw error('FragmentDefinition');\n  ignored();\n  if (advance(nameRe) !== 'on') throw error('FragmentDefinition');\n  ignored();\n  if ((_condition = advance(nameRe)) == null) throw error('FragmentDefinition');\n  ignored();\n  const _directives = directives(false);\n  if (input.charCodeAt(idx++) !== 123 /*'{'*/) throw error('FragmentDefinition');\n  ignored();\n  return {\n    kind: 'FragmentDefinition' as Kind.FRAGMENT_DEFINITION,\n    name: { kind: 'Name' as Kind.NAME, value: _name },\n    typeCondition: {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: { kind: 'Name' as Kind.NAME, value: _condition },\n    },\n    directives: _directives,\n    selectionSet: selectionSet(),\n  };\n}\n\nconst definitionRe = /(?:query|mutation|subscription|fragment)/y;\n\nfunction operationDefinition(\n  operation: OperationTypeNode | undefined\n): ast.OperationDefinitionNode | undefined {\n  let _name: string | undefined;\n  let _variableDefinitions: ast.VariableDefinitionNode[] | undefined;\n  let _directives: ast.DirectiveNode[] | undefined;\n  if (operation) {\n    ignored();\n    _name = advance(nameRe);\n    _variableDefinitions = variableDefinitions();\n    _directives = directives(false);\n  }\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    return {\n      kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n      operation: operation || ('query' as OperationTypeNode.QUERY),\n      name: _name ? { kind: 'Name' as Kind.NAME, value: _name } : undefined,\n      variableDefinitions: _variableDefinitions,\n      directives: _directives,\n      selectionSet: selectionSet(),\n    };\n  }\n}\n\nfunction document(input: string, noLoc: boolean): ast.DocumentNode {\n  let match: string | undefined;\n  let definition: ast.OperationDefinitionNode | undefined;\n  ignored();\n  const definitions: ast.ExecutableDefinitionNode[] = [];\n  do {\n    if ((match = advance(definitionRe)) === 'fragment') {\n      ignored();\n      definitions.push(fragmentDefinition());\n    } else if ((definition = operationDefinition(match as OperationTypeNode)) != null) {\n      definitions.push(definition);\n    } else {\n      throw error('Document');\n    }\n  } while (idx < input.length);\n\n  if (!noLoc) {\n    let loc: Location | undefined;\n    return {\n      kind: 'Document' as Kind.DOCUMENT,\n      definitions,\n      /* v8 ignore start */\n      set loc(_loc: Location) {\n        loc = _loc;\n      },\n      /* v8 ignore stop */\n      // @ts-ignore\n      get loc() {\n        if (!loc) {\n          loc = {\n            start: 0,\n            end: input.length,\n            startToken: undefined,\n            endToken: undefined,\n            source: {\n              body: input,\n              name: 'graphql.web',\n              locationOffset: { line: 1, column: 1 },\n            },\n          };\n        }\n        return loc;\n      },\n    };\n  }\n\n  return {\n    kind: 'Document' as Kind.DOCUMENT,\n    definitions,\n  };\n}\n\ntype ParseOptions = {\n  [option: string]: any;\n};\n\nexport function parse(\n  string: string | Source,\n  options?: ParseOptions | undefined\n): ast.DocumentNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return document(input, options && options.noLocation);\n}\n\nexport function parseValue(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.ValueNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  ignored();\n  return value(false);\n}\n\nexport function parseType(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.TypeNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return type();\n}\n","import type { ASTNode } from './ast';\n\nexport const BREAK = {};\n\nexport function visit<N extends ASTNode>(root: N, visitor: ASTVisitor): N;\nexport function visit<R>(root: ASTNode, visitor: ASTReducer<R>): R;\n\nexport function visit(node: ASTNode, visitor: ASTVisitor | ASTReducer<any>) {\n  const ancestors: Array<ASTNode | ReadonlyArray<ASTNode>> = [];\n  const path: Array<string | number> = [];\n\n  function traverse(\n    node: ASTNode,\n    key?: string | number | undefined,\n    parent?: ASTNode | ReadonlyArray<ASTNode> | undefined\n  ) {\n    let hasEdited = false;\n\n    const enter =\n      (visitor[node.kind] && visitor[node.kind].enter) ||\n      visitor[node.kind] ||\n      (visitor as EnterLeaveVisitor<ASTNode>).enter;\n    const resultEnter = enter && enter.call(visitor, node, key, parent, path, ancestors);\n    if (resultEnter === false) {\n      return node;\n    } else if (resultEnter === null) {\n      return null;\n    } else if (resultEnter === BREAK) {\n      throw BREAK;\n    } else if (resultEnter && typeof resultEnter.kind === 'string') {\n      hasEdited = resultEnter !== node;\n      node = resultEnter;\n    }\n\n    if (parent) ancestors.push(parent);\n\n    let result: any;\n    const copy = { ...node };\n    for (const nodeKey in node) {\n      path.push(nodeKey);\n      let value = node[nodeKey];\n      if (Array.isArray(value)) {\n        const newValue: any[] = [];\n        for (let index = 0; index < value.length; index++) {\n          if (value[index] != null && typeof value[index].kind === 'string') {\n            ancestors.push(node);\n            path.push(index);\n            result = traverse(value[index], index, value);\n            path.pop();\n            ancestors.pop();\n            if (result == null) {\n              hasEdited = true;\n            } else {\n              hasEdited = hasEdited || result !== value[index];\n              newValue.push(result);\n            }\n          }\n        }\n        value = newValue;\n      } else if (value != null && typeof value.kind === 'string') {\n        result = traverse(value, nodeKey, node);\n        if (result !== undefined) {\n          hasEdited = hasEdited || value !== result;\n          value = result;\n        }\n      }\n\n      path.pop();\n      if (hasEdited) copy[nodeKey] = value;\n    }\n\n    if (parent) ancestors.pop();\n    const leave =\n      (visitor[node.kind] && visitor[node.kind].leave) ||\n      (visitor as EnterLeaveVisitor<ASTNode>).leave;\n    const resultLeave = leave && leave.call(visitor, node, key, parent, path, ancestors);\n    if (resultLeave === BREAK) {\n      throw BREAK;\n    } else if (resultLeave !== undefined) {\n      return resultLeave;\n    } else if (resultEnter !== undefined) {\n      return hasEdited ? copy : resultEnter;\n    } else {\n      return hasEdited ? copy : node;\n    }\n  }\n\n  try {\n    const result = traverse(node);\n    return result !== undefined && result !== false ? result : node;\n  } catch (error) {\n    if (error !== BREAK) throw error;\n    return node;\n  }\n}\n\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: ASTVisitFn<NodeT> | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\nexport type ASTVisitFn<Node extends ASTNode> = (\n  node: Node,\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => any;\n\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => R;\n\ntype ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n    ? ReadonlyArray<R>\n    : R;\n","import type {\n  ASTNode,\n  NameNode,\n  DocumentNode,\n  VariableNode,\n  SelectionSetNode,\n  FieldNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  NullValueNode,\n  EnumValueNode,\n  ListValueNode,\n  ObjectValueNode,\n  ObjectFieldNode,\n  DirectiveNode,\n  NamedTypeNode,\n  ListTypeNode,\n  NonNullTypeNode,\n} from './ast';\n\nfunction mapJoin<T>(value: readonly T[], joiner: string, mapper: (value: T) => string): string {\n  let out = '';\n  for (let index = 0; index < value.length; index++) {\n    if (index) out += joiner;\n    out += mapper(value[index]);\n  }\n  return out;\n}\n\nfunction printString(string: string): string {\n  return JSON.stringify(string);\n}\n\nfunction printBlockString(string: string): string {\n  return '\"\"\"\\n' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nconst MAX_LINE_LENGTH = 80;\n\nlet LF = '\\n';\n\nconst nodes = {\n  OperationDefinition(node: OperationDefinitionNode): string {\n    let out: string = node.operation;\n    if (node.name) out += ' ' + node.name.value;\n    if (node.variableDefinitions && node.variableDefinitions.length) {\n      if (!node.name) out += ' ';\n      out += '(' + mapJoin(node.variableDefinitions, ', ', nodes.VariableDefinition) + ')';\n    }\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out !== 'query'\n      ? out + ' ' + nodes.SelectionSet(node.selectionSet)\n      : nodes.SelectionSet(node.selectionSet);\n  },\n  VariableDefinition(node: VariableDefinitionNode): string {\n    let out = nodes.Variable!(node.variable) + ': ' + _print(node.type);\n    if (node.defaultValue) out += ' = ' + _print(node.defaultValue);\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out;\n  },\n  Field(node: FieldNode): string {\n    let out = node.alias ? node.alias.value + ': ' + node.name.value : node.name.value;\n    if (node.arguments && node.arguments.length) {\n      const args = mapJoin(node.arguments, ', ', nodes.Argument);\n      if (out.length + args.length + 2 > MAX_LINE_LENGTH) {\n        out +=\n          '(' +\n          (LF += '  ') +\n          mapJoin(node.arguments, LF, nodes.Argument) +\n          (LF = LF.slice(0, -2)) +\n          ')';\n      } else {\n        out += '(' + args + ')';\n      }\n    }\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    if (node.selectionSet && node.selectionSet.selections.length) {\n      out += ' ' + nodes.SelectionSet(node.selectionSet);\n    }\n    return out;\n  },\n  StringValue(node: StringValueNode): string {\n    if (node.block) {\n      return printBlockString(node.value).replace(/\\n/g, LF);\n    } else {\n      return printString(node.value);\n    }\n  },\n  BooleanValue(node: BooleanValueNode): string {\n    return '' + node.value;\n  },\n  NullValue(_node: NullValueNode): string {\n    return 'null';\n  },\n  IntValue(node: IntValueNode): string {\n    return node.value;\n  },\n  FloatValue(node: FloatValueNode): string {\n    return node.value;\n  },\n  EnumValue(node: EnumValueNode): string {\n    return node.value;\n  },\n  Name(node: NameNode): string {\n    return node.value;\n  },\n  Variable(node: VariableNode): string {\n    return '$' + node.name.value;\n  },\n  ListValue(node: ListValueNode): string {\n    return '[' + mapJoin(node.values, ', ', _print) + ']';\n  },\n  ObjectValue(node: ObjectValueNode): string {\n    return '{' + mapJoin(node.fields, ', ', nodes.ObjectField) + '}';\n  },\n  ObjectField(node: ObjectFieldNode): string {\n    return node.name.value + ': ' + _print(node.value);\n  },\n  Document(node: DocumentNode): string {\n    if (!node.definitions || !node.definitions.length) return '';\n    return mapJoin(node.definitions, '\\n\\n', _print);\n  },\n  SelectionSet(node: SelectionSetNode): string {\n    return '{' + (LF += '  ') + mapJoin(node.selections, LF, _print) + (LF = LF.slice(0, -2)) + '}';\n  },\n  Argument(node: ArgumentNode): string {\n    return node.name.value + ': ' + _print(node.value);\n  },\n  FragmentSpread(node: FragmentSpreadNode): string {\n    let out = '...' + node.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out;\n  },\n  InlineFragment(node: InlineFragmentNode): string {\n    let out = '...';\n    if (node.typeCondition) out += ' on ' + node.typeCondition.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    out += ' ' + nodes.SelectionSet(node.selectionSet);\n    return out;\n  },\n  FragmentDefinition(node: FragmentDefinitionNode): string {\n    let out = 'fragment ' + node.name.value;\n    out += ' on ' + node.typeCondition.name.value;\n    if (node.directives && node.directives.length)\n      out += ' ' + mapJoin(node.directives, ' ', nodes.Directive);\n    return out + ' ' + nodes.SelectionSet(node.selectionSet);\n  },\n  Directive(node: DirectiveNode): string {\n    let out = '@' + node.name.value;\n    if (node.arguments && node.arguments.length)\n      out += '(' + mapJoin(node.arguments, ', ', nodes.Argument) + ')';\n    return out;\n  },\n  NamedType(node: NamedTypeNode): string {\n    return node.name.value;\n  },\n  ListType(node: ListTypeNode): string {\n    return '[' + _print(node.type) + ']';\n  },\n  NonNullType(node: NonNullTypeNode): string {\n    return _print(node.type) + '!';\n  },\n} as const;\n\nconst _print = (node: ASTNode): string => nodes[node.kind](node);\n\nfunction print(node: ASTNode): string {\n  LF = '\\n';\n  return nodes[node.kind] ? nodes[node.kind](node) : '';\n}\n\nexport { print, printString, printBlockString };\n","import type { TypeNode, ValueNode } from './ast';\nimport type { Maybe } from './types';\n\nexport function valueFromASTUntyped(\n  node: ValueNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  switch (node.kind) {\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'StringValue':\n    case 'EnumValue':\n    case 'BooleanValue':\n      return node.value;\n    case 'ListValue': {\n      const values: unknown[] = [];\n      for (let i = 0, l = node.values.length; i < l; i++)\n        values.push(valueFromASTUntyped(node.values[i], variables));\n      return values;\n    }\n    case 'ObjectValue': {\n      const obj = Object.create(null);\n      for (let i = 0, l = node.fields.length; i < l; i++) {\n        const field = node.fields[i];\n        obj[field.name.value] = valueFromASTUntyped(field.value, variables);\n      }\n      return obj;\n    }\n    case 'Variable':\n      return variables && variables[node.name.value];\n  }\n}\n\nexport function valueFromTypeNode(\n  node: ValueNode,\n  type: TypeNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  if (node.kind === 'Variable') {\n    const variableName = node.name.value;\n    return variables ? valueFromTypeNode(variables[variableName], type, variables) : undefined;\n  } else if (type.kind === 'NonNullType') {\n    return node.kind !== 'NullValue' ? valueFromTypeNode(node, type, variables) : undefined;\n  } else if (node.kind === 'NullValue') {\n    return null;\n  } else if (type.kind === 'ListType') {\n    if (node.kind === 'ListValue') {\n      const values: unknown[] = [];\n      for (let i = 0, l = node.values.length; i < l; i++) {\n        const value = node.values[i];\n        const coerced = valueFromTypeNode(value, type.type, variables);\n        if (coerced === undefined) {\n          return undefined;\n        } else {\n          values.push(coerced);\n        }\n      }\n      return values;\n    }\n  } else if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Int':\n      case 'Float':\n      case 'String':\n      case 'Bool':\n        return type.name.value + 'Value' === node.kind\n          ? valueFromASTUntyped(node, variables)\n          : undefined;\n      default:\n        return valueFromASTUntyped(node, variables);\n    }\n  }\n}\n","import type { Location, Source as _Source } from './types';\nimport type { ASTNode, SelectionNode } from './ast';\n\nexport function isSelectionNode(node: ASTNode): node is SelectionNode {\n  return node.kind === 'Field' || node.kind === 'FragmentSpread' || node.kind === 'InlineFragment';\n}\n\nexport function Source(body: string, name?: string, locationOffset?: Location): _Source {\n  return {\n    body,\n    name,\n    locationOffset: locationOffset || { line: 1, column: 1 },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}