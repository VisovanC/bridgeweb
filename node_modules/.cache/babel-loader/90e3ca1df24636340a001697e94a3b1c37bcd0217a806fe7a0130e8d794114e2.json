{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _data, _client, _legacyAddress, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn;\nimport { fromBase64, toBase64, toHex } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { PublicKey } from \"../cryptography/publickey.js\";\nimport { SIGNATURE_SCHEME_TO_FLAG } from \"../cryptography/signature-scheme.js\";\nimport { SuiGraphQLClient } from \"../graphql/client.js\";\nimport { graphql } from \"../graphql/schemas/latest/index.js\";\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { extractClaimValue } from \"./jwt-utils.js\";\nimport { parseZkLoginSignature } from \"./signature.js\";\nimport { toBigEndianBytes, toPaddedBigEndianBytes } from \"./utils.js\";\nconst _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier extends PublicKey {\n  /**\n   * Create a new ZkLoginPublicIdentifier object\n   * @param value zkLogin public identifier as buffer or base-64 encoded string\n   */\n  constructor(value, {\n    client\n  } = {}) {\n    super();\n    __privateAdd(this, _ZkLoginPublicIdentifier_instances);\n    __privateAdd(this, _data);\n    __privateAdd(this, _client);\n    __privateAdd(this, _legacyAddress);\n    __privateSet(this, _client, client);\n    if (typeof value === \"string\") {\n      __privateSet(this, _data, fromBase64(value));\n    } else if (value instanceof Uint8Array) {\n      __privateSet(this, _data, value);\n    } else {\n      __privateSet(this, _data, Uint8Array.from(value));\n    }\n    __privateSet(this, _legacyAddress, __privateGet(this, _data).length !== __privateGet(this, _data)[0] + 1 + 32);\n    if (__privateGet(this, _legacyAddress)) {\n      __privateSet(this, _data, normalizeZkLoginPublicKeyBytes(__privateGet(this, _data)));\n    }\n  }\n  /**\n   * Checks if two zkLogin public identifiers are equal\n   */\n  equals(publicKey) {\n    return super.equals(publicKey);\n  }\n  toSuiAddress() {\n    if (__privateGet(this, _legacyAddress)) {\n      return __privateMethod(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);\n    }\n    return super.toSuiAddress();\n  }\n  /**\n   * Return the byte array representation of the zkLogin public identifier\n   */\n  toRawBytes() {\n    return __privateGet(this, _data);\n  }\n  /**\n   * Return the Sui address associated with this ZkLogin public identifier\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"ZkLogin\"];\n  }\n  /**\n   * Verifies that the signature is valid for for the provided message\n   */\n  async verify(_message, _signature) {\n    throw Error(\"does not support\");\n  }\n  /**\n   * Verifies that the signature is valid for for the provided PersonalMessage\n   */\n  verifyPersonalMessage(message, signature) {\n    const parsedSignature = parseSerializedZkLoginSignature(signature);\n    const address = new _ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n    return graphqlVerifyZkLoginSignature({\n      address,\n      bytes: toBase64(message),\n      signature: parsedSignature.serializedSignature,\n      intentScope: \"PERSONAL_MESSAGE\",\n      client: __privateGet(this, _client)\n    });\n  }\n  /**\n   * Verifies that the signature is valid for for the provided Transaction\n   */\n  verifyTransaction(transaction, signature) {\n    const parsedSignature = parseSerializedZkLoginSignature(signature);\n    const address = new _ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n    return graphqlVerifyZkLoginSignature({\n      address,\n      bytes: toBase64(transaction),\n      signature: parsedSignature.serializedSignature,\n      intentScope: \"TRANSACTION_DATA\",\n      client: __privateGet(this, _client)\n    });\n  }\n  /**\n   * Verifies that the public key is associated with the provided address\n   */\n  verifyAddress(address) {\n    return address === super.toSuiAddress() || address === __privateMethod(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);\n  }\n};\n_data = new WeakMap();\n_client = new WeakMap();\n_legacyAddress = new WeakMap();\n_ZkLoginPublicIdentifier_instances = new WeakSet();\ntoLegacyAddress_fn = function () {\n  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet(this, _data), true);\n  const addressBytes = new Uint8Array(legacyBytes.length + 1);\n  addressBytes[0] = this.flag();\n  addressBytes.set(legacyBytes, 1);\n  return normalizeSuiAddress(bytesToHex(blake2b(addressBytes, {\n    dkLen: 32\n  })).slice(0, SUI_ADDRESS_LENGTH * 2));\n};\nlet ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;\nfunction toZkLoginPublicIdentifier(addressSeed, iss, options) {\n  const addressSeedBytesBigEndian = options?.legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);\n  const issBytes = new TextEncoder().encode(iss);\n  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n  tmp.set([issBytes.length], 0);\n  tmp.set(issBytes, 1);\n  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n  return new ZkLoginPublicIdentifier(tmp, options);\n}\nconst VerifyZkLoginSignatureQuery = graphql(`\n\tquery Zklogin(\n\t\t$bytes: Base64!\n\t\t$signature: Base64!\n\t\t$intentScope: ZkLoginIntentScope!\n\t\t$author: SuiAddress!\n\t) {\n\t\tverifyZkloginSignature(\n\t\t\tbytes: $bytes\n\t\t\tsignature: $signature\n\t\t\tintentScope: $intentScope\n\t\t\tauthor: $author\n\t\t) {\n\t\t\tsuccess\n\t\t\terrors\n\t\t}\n\t}\n`);\nfunction normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {\n  const issByteLength = bytes[0] + 1;\n  const addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);\n  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);\n  const data = new Uint8Array(issByteLength + seedBytes.length);\n  data.set(bytes.slice(0, issByteLength), 0);\n  data.set(seedBytes, issByteLength);\n  return data;\n}\nasync function graphqlVerifyZkLoginSignature({\n  address,\n  bytes,\n  signature,\n  intentScope,\n  client = new SuiGraphQLClient({\n    url: \"https://sui-mainnet.mystenlabs.com/graphql\"\n  })\n}) {\n  const resp = await client.query({\n    query: VerifyZkLoginSignatureQuery,\n    variables: {\n      bytes,\n      signature,\n      intentScope,\n      author: address\n    }\n  });\n  return resp.data?.verifyZkloginSignature.success === true && resp.data?.verifyZkloginSignature.errors.length === 0;\n}\nfunction parseSerializedZkLoginSignature(signature) {\n  const bytes = typeof signature === \"string\" ? fromBase64(signature) : signature;\n  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n    throw new Error(\"Invalid signature scheme\");\n  }\n  const signatureBytes = bytes.slice(1);\n  const {\n    inputs,\n    maxEpoch,\n    userSignature\n  } = parseZkLoginSignature(signatureBytes);\n  const {\n    issBase64Details,\n    addressSeed\n  } = inputs;\n  const iss = extractClaimValue(issBase64Details, \"iss\");\n  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n  return {\n    serializedSignature: toBase64(bytes),\n    signatureScheme: \"ZkLogin\",\n    zkLogin: {\n      inputs,\n      maxEpoch,\n      userSignature,\n      iss,\n      addressSeed: BigInt(addressSeed)\n    },\n    signature: bytes,\n    publicKey: publicIdentifer.toRawBytes()\n  };\n}\nexport { ZkLoginPublicIdentifier, parseSerializedZkLoginSignature, toZkLoginPublicIdentifier };","map":{"version":3,"names":["_data","_client","_legacyAddress","_ZkLoginPublicIdentifier_instances","toLegacyAddress_fn","fromBase64","toBase64","toHex","blake2b","bytesToHex","PublicKey","SIGNATURE_SCHEME_TO_FLAG","SuiGraphQLClient","graphql","normalizeSuiAddress","SUI_ADDRESS_LENGTH","extractClaimValue","parseZkLoginSignature","toBigEndianBytes","toPaddedBigEndianBytes","_ZkLoginPublicIdentifier","constructor","value","client","__privateAdd","__privateSet","Uint8Array","from","__privateGet","length","normalizeZkLoginPublicKeyBytes","equals","publicKey","toSuiAddress","__privateMethod","call","toRawBytes","flag","verify","_message","_signature","Error","verifyPersonalMessage","message","signature","parsedSignature","parseSerializedZkLoginSignature","address","graphqlVerifyZkLoginSignature","bytes","serializedSignature","intentScope","verifyTransaction","transaction","verifyAddress","WeakMap","WeakSet","legacyBytes","addressBytes","set","dkLen","slice","ZkLoginPublicIdentifier","toZkLoginPublicIdentifier","addressSeed","iss","options","addressSeedBytesBigEndian","legacyAddress","issBytes","TextEncoder","encode","tmp","VerifyZkLoginSignatureQuery","issByteLength","BigInt","seedBytes","data","url","resp","query","variables","author","verifyZkloginSignature","success","errors","ZkLogin","signatureBytes","inputs","maxEpoch","userSignature","issBase64Details","publicIdentifer","signatureScheme","zkLogin"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/sui/src/zklogin/publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64, toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { PublicKey } from '../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../cryptography/signature-scheme.js';\nimport { SuiGraphQLClient } from '../graphql/client.js';\nimport { graphql } from '../graphql/schemas/latest/index.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { extractClaimValue } from './jwt-utils.js';\nimport { parseZkLoginSignature } from './signature.js';\nimport { toBigEndianBytes, toPaddedBigEndianBytes } from './utils.js';\n\n/**\n * A zkLogin public identifier\n */\nexport class ZkLoginPublicIdentifier extends PublicKey {\n\t#data: Uint8Array;\n\t#client?: SuiGraphQLClient;\n\t#legacyAddress: boolean;\n\n\t/**\n\t * Create a new ZkLoginPublicIdentifier object\n\t * @param value zkLogin public identifier as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData, { client }: { client?: SuiGraphQLClient } = {}) {\n\t\tsuper();\n\n\t\tthis.#client = client;\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.#data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.#data = value;\n\t\t} else {\n\t\t\tthis.#data = Uint8Array.from(value);\n\t\t}\n\t\tthis.#legacyAddress = this.#data.length !== this.#data[0] + 1 + 32;\n\n\t\tif (this.#legacyAddress) {\n\t\t\tthis.#data = normalizeZkLoginPublicKeyBytes(this.#data);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two zkLogin public identifiers are equal\n\t */\n\toverride equals(publicKey: ZkLoginPublicIdentifier): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\toverride toSuiAddress(): string {\n\t\tif (this.#legacyAddress) {\n\t\t\treturn this.#toLegacyAddress();\n\t\t}\n\n\t\treturn super.toSuiAddress();\n\t}\n\n\t#toLegacyAddress() {\n\t\tconst legacyBytes = normalizeZkLoginPublicKeyBytes(this.#data, true);\n\t\tconst addressBytes = new Uint8Array(legacyBytes.length + 1);\n\t\taddressBytes[0] = this.flag();\n\t\taddressBytes.set(legacyBytes, 1);\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the zkLogin public identifier\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this ZkLogin public identifier\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['ZkLogin'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(_message: Uint8Array, _signature: Uint8Array | string): Promise<boolean> {\n\t\tthrow Error('does not support');\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(message),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'PERSONAL_MESSAGE',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(transaction),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'TRANSACTION_DATA',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the public key is associated with the provided address\n\t */\n\toverride verifyAddress(address: string): boolean {\n\t\treturn address === super.toSuiAddress() || address === this.#toLegacyAddress();\n\t}\n}\n\n// Derive the public identifier for zklogin based on address seed and iss.\nexport function toZkLoginPublicIdentifier(\n\taddressSeed: bigint,\n\tiss: string,\n\toptions?: { client?: SuiGraphQLClient; legacyAddress?: boolean },\n): ZkLoginPublicIdentifier {\n\t// Consists of iss_bytes_len || iss_bytes || padded_32_byte_address_seed.\n\tconst addressSeedBytesBigEndian = options?.legacyAddress\n\t\t? toBigEndianBytes(addressSeed, 32)\n\t\t: toPaddedBigEndianBytes(addressSeed, 32);\n\n\tconst issBytes = new TextEncoder().encode(iss);\n\tconst tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n\ttmp.set([issBytes.length], 0);\n\ttmp.set(issBytes, 1);\n\ttmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n\treturn new ZkLoginPublicIdentifier(tmp, options);\n}\n\nconst VerifyZkLoginSignatureQuery = graphql(`\n\tquery Zklogin(\n\t\t$bytes: Base64!\n\t\t$signature: Base64!\n\t\t$intentScope: ZkLoginIntentScope!\n\t\t$author: SuiAddress!\n\t) {\n\t\tverifyZkloginSignature(\n\t\t\tbytes: $bytes\n\t\t\tsignature: $signature\n\t\t\tintentScope: $intentScope\n\t\t\tauthor: $author\n\t\t) {\n\t\t\tsuccess\n\t\t\terrors\n\t\t}\n\t}\n`);\n\nfunction normalizeZkLoginPublicKeyBytes(bytes: Uint8Array, legacyAddress = false) {\n\tconst issByteLength = bytes[0] + 1;\n\tconst addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);\n\tconst seedBytes = legacyAddress\n\t\t? toBigEndianBytes(addressSeed, 32)\n\t\t: toPaddedBigEndianBytes(addressSeed, 32);\n\tconst data = new Uint8Array(issByteLength + seedBytes.length);\n\tdata.set(bytes.slice(0, issByteLength), 0);\n\tdata.set(seedBytes, issByteLength);\n\treturn data;\n}\n\nasync function graphqlVerifyZkLoginSignature({\n\taddress,\n\tbytes,\n\tsignature,\n\tintentScope,\n\tclient = new SuiGraphQLClient({\n\t\turl: 'https://sui-mainnet.mystenlabs.com/graphql',\n\t}),\n}: {\n\taddress: string;\n\tbytes: string;\n\tsignature: string;\n\tintentScope: 'PERSONAL_MESSAGE' | 'TRANSACTION_DATA';\n\tclient?: SuiGraphQLClient;\n}) {\n\tconst resp = await client.query({\n\t\tquery: VerifyZkLoginSignatureQuery,\n\t\tvariables: {\n\t\t\tbytes,\n\t\t\tsignature,\n\t\t\tintentScope,\n\t\t\tauthor: address,\n\t\t},\n\t});\n\n\treturn (\n\t\tresp.data?.verifyZkloginSignature.success === true &&\n\t\tresp.data?.verifyZkloginSignature.errors.length === 0\n\t);\n}\n\nexport function parseSerializedZkLoginSignature(signature: Uint8Array | string) {\n\tconst bytes = typeof signature === 'string' ? fromBase64(signature) : signature;\n\n\tif (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n\t\tthrow new Error('Invalid signature scheme');\n\t}\n\n\tconst signatureBytes = bytes.slice(1);\n\tconst { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);\n\tconst { issBase64Details, addressSeed } = inputs;\n\tconst iss = extractClaimValue<string>(issBase64Details, 'iss');\n\tconst publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n\treturn {\n\t\tserializedSignature: toBase64(bytes),\n\t\tsignatureScheme: 'ZkLogin' as const,\n\t\tzkLogin: {\n\t\t\tinputs,\n\t\t\tmaxEpoch,\n\t\t\tuserSignature,\n\t\t\tiss,\n\t\t\taddressSeed: BigInt(addressSeed),\n\t\t},\n\t\tsignature: bytes,\n\t\tpublicKey: publicIdentifer.toRawBytes(),\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}