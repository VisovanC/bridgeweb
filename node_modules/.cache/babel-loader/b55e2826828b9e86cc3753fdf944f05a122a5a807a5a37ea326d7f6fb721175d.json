{"ast":null,"code":"import { fromB58, toB58 } from \"./b58.js\";\nimport { fromB64, toB64 } from \"./b64.js\";\nimport { BcsType } from \"./bcs-type.js\";\nimport { fromHEX, toHEX } from \"./hex.js\";\nimport { BcsReader } from \"./reader.js\";\nimport { decodeStr, splitGenericParameters } from \"./utils.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst SUI_ADDRESS_LENGTH = 32;\nconst _BCS = class {\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema) {\n    /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */\n    this.types = /* @__PURE__ */new Map();\n    /**\n     * Count temp keys to generate a new one when requested.\n     */\n    this.counter = 0;\n    if (schema instanceof _BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n    this.schema = schema;\n    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n    this.registerVectorType(schema.vectorType);\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  ser(type, data, options) {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(this, data, options, params);\n    }\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new _BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n    throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  de(type, data, encoding) {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params);\n    }\n    if (typeof type === \"object\") {\n      const temp = new _BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n    throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  hasType(type) {\n    return this.types.has(type);\n  }\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  registerAlias(name, forType) {\n    this.types.set(name, forType);\n    return this;\n  }\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {\n    const {\n      name,\n      params: generics\n    } = this.parseTypeName(typeName);\n    this.types.set(name, {\n      encode(self, data, options, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n      },\n      decode(self, data, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n      },\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      }\n    });\n    return this;\n  }\n  /**\n  \t * Method to register BcsType instances to the registry\n  \t * Types are registered with a callback that provides BcsType instances for each generic\n  \t * passed to the type.\n  \t *\n  \t * - createType(...generics) - Return a BcsType instance\n  \t *\n  \t * @example\n  \t * // our type would be a string that consists only of numbers\n  \t * bcs.registerType('Box<T>', (T) => {\n  \t * \t\treturn bcs.struct({\n  \t * \t\t\tvalue: T\n  \t * \t\t});\n  \t * });\n  \n  \t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n  \t *\n  \t * @param name\n  \t * @param createType a Callback to create the BcsType with any passed in generics\n  \t */\n  registerBcsType(typeName, createType) {\n    this.registerType(typeName, (writer, data, typeParams) => {\n      const generics = typeParams.map(param => new BcsType({\n        name: String(param),\n        write: (data2, writer2) => {\n          const {\n            name,\n            params\n          } = this.parseTypeName(param);\n          const typeInterface = this.getTypeInterface(name);\n          const typeMap = params.reduce((acc, value, index) => {\n            return Object.assign(acc, {\n              [value]: typeParams[index]\n            });\n          }, {});\n          return typeInterface._encodeRaw.call(this, writer2, data2, params, typeMap);\n        },\n        read: () => {\n          throw new Error(\"Not implemented\");\n        }\n      }));\n      createType(...generics).write(data, writer);\n      return writer;\n    }, (reader, typeParams) => {\n      const generics = typeParams.map(param => new BcsType({\n        name: String(param),\n        write: (_data, _writer) => {\n          throw new Error(\"Not implemented\");\n        },\n        read: reader2 => {\n          const {\n            name,\n            params\n          } = this.parseTypeName(param);\n          const typeInterface = this.getTypeInterface(name);\n          const typeMap = params.reduce((acc, value, index) => {\n            return Object.assign(acc, {\n              [value]: typeParams[index]\n            });\n          }, {});\n          return typeInterface._decodeRaw.call(this, reader2, params, typeMap);\n        }\n      }));\n      return createType(...generics).read(reader);\n    });\n    return this;\n  }\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  registerAddressType(name, length, encoding = \"hex\") {\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toB64(reader.readBytes(length));\n        });\n      case \"hex\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toHEX(reader.readBytes(length));\n        });\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  registerVectorType(typeName) {\n    let {\n      name,\n      params\n    } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n    return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {\n      return writer.writeVec(data, (writer2, el) => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._encodeRaw.call(this, writer2, el, innerParams, typeMap);\n      });\n    }, function decodeVector(reader, typeParams, typeMap) {\n      return reader.readVec(reader2 => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._decodeRaw.call(this, reader2, innerParams, typeMap);\n      });\n    });\n  }\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  registerStructType(typeName, fields) {\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(fields);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name: structName,\n      params: generics\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {\n      if (!data || data.constructor !== Object) {\n        throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n      }\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      for (let key of canonicalOrder) {\n        if (!(key in data)) {\n          throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n        }\n        const {\n          name: fieldType,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldType)) {\n          this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldType);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);\n        }\n      }\n      return writer;\n    }, function decodeStruct(reader, typeParams, typeMap) {\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      let result = {};\n      for (let key of canonicalOrder) {\n        const {\n          name: fieldName,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldName)) {\n          result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldName);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);\n        }\n      }\n      return result;\n    });\n  }\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  registerEnumType(typeName, variants) {\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n      if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(variants);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name,\n      params: canonicalTypeParams\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {\n      if (!data) {\n        throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n      }\n      if (typeof data !== \"object\") {\n        throw new Error(`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\" | \")}\".\nReceived: \"${JSON.stringify(data)}\"`);\n      }\n      let key = Object.keys(data)[0];\n      if (key === void 0) {\n        throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n      }\n      let orderByte = canonicalOrder.indexOf(key);\n      if (orderByte === -1) {\n        throw new Error(`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\" | \")}\"; received \"${key}\"`);\n      }\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      writer.write8(orderByte);\n      if (invariantType === null) {\n        return writer;\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return this.getTypeInterface(name2)._encodeRaw.call(this, writer, data[key], params, typeMap);\n      }\n    }, function decodeEnum(reader, typeParams, typeMap) {\n      let orderByte = reader.readULEB();\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      if (orderByte === -1) {\n        throw new Error(`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`);\n      }\n      if (invariantType === null) {\n        return {\n          [invariant]: true\n        };\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return {\n          [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n        };\n      }\n    });\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  getTypeInterface(type) {\n    let typeInterface = this.types.get(type);\n    if (typeof typeInterface === \"string\") {\n      let chain = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n    if (typeInterface === void 0) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n    return typeInterface;\n  }\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  parseTypeName(name) {\n    if (Array.isArray(name)) {\n      let [typeName2, ...params2] = name;\n      return {\n        name: typeName2,\n        params: params2\n      };\n    }\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n    if (l_bound === -1 && r_bound === -1) {\n      return {\n        name,\n        params: []\n      };\n    }\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n    let typeName = name.slice(0, l_bound);\n    let params = splitGenericParameters(name.slice(l_bound + 1, name.length - r_bound - 1), this.schema.genericSeparators);\n    return {\n      name: typeName,\n      params\n    };\n  }\n};\nlet BCS = _BCS;\n// Predefined types constants\nBCS.U8 = \"u8\";\nBCS.U16 = \"u16\";\nBCS.U32 = \"u32\";\nBCS.U64 = \"u64\";\nBCS.U128 = \"u128\";\nBCS.U256 = \"u256\";\nBCS.BOOL = \"bool\";\nBCS.VECTOR = \"vector\";\nBCS.ADDRESS = \"address\";\nBCS.STRING = \"string\";\nBCS.HEX = \"hex-string\";\nBCS.BASE58 = \"base58-string\";\nBCS.BASE64 = \"base64-string\";\nfunction registerPrimitives(bcs) {\n  bcs.registerType(BCS.U8, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8();\n  }, u8 => u8 < 256);\n  bcs.registerType(BCS.U16, function (writer, data) {\n    return writer.write16(data);\n  }, function (reader) {\n    return reader.read16();\n  }, u16 => u16 < 65536);\n  bcs.registerType(BCS.U32, function (writer, data) {\n    return writer.write32(data);\n  }, function (reader) {\n    return reader.read32();\n  }, u32 => u32 <= 4294967296n);\n  bcs.registerType(BCS.U64, function (writer, data) {\n    return writer.write64(data);\n  }, function (reader) {\n    return reader.read64();\n  });\n  bcs.registerType(BCS.U128, function (writer, data) {\n    return writer.write128(data);\n  }, function (reader) {\n    return reader.read128();\n  });\n  bcs.registerType(BCS.U256, function (writer, data) {\n    return writer.write256(data);\n  }, function (reader) {\n    return reader.read256();\n  });\n  bcs.registerType(BCS.BOOL, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8().toString(10) === \"1\";\n  });\n  bcs.registerType(BCS.STRING, function (writer, data) {\n    return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));\n  }, function (reader) {\n    return reader.readVec(reader2 => reader2.read8()).map(el => String.fromCharCode(Number(el))).join(\"\");\n  }, _str => true);\n  bcs.registerType(BCS.HEX, function (writer, data) {\n    return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toHEX(new Uint8Array(bytes));\n  });\n  bcs.registerType(BCS.BASE58, function (writer, data) {\n    return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB58(new Uint8Array(bytes));\n  });\n  bcs.registerType(BCS.BASE64, function (writer, data) {\n    return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB64(new Uint8Array(bytes));\n  });\n}\nfunction getRustConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction getSuiMoveConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nexport { BCS, getRustConfig, getSuiMoveConfig, registerPrimitives };","map":{"version":3,"names":["fromB58","toB58","fromB64","toB64","BcsType","fromHEX","toHEX","BcsReader","decodeStr","splitGenericParameters","BcsWriter","SUI_ADDRESS_LENGTH","_BCS","constructor","schema","types","Map","counter","registerAddressType","ADDRESS","addressLength","addressEncoding","registerVectorType","vectorType","structs","name","Object","keys","registerStructType","enums","registerEnumType","aliases","registerAlias","withPrimitives","registerPrimitives","tempKey","ser","type","data","options","Array","isArray","params","parseTypeName","getTypeInterface","encode","key","temp","Error","JSON","stringify","de","encoding","decode","hasType","has","forType","set","registerType","typeName","encodeCb","decodeCb","validateCb","generics","self","typeParams","typeMap","reduce","acc","value","index","assign","_encodeRaw","call","_decodeRaw","writer","reader","registerBcsType","createType","map","param","String","write","data2","writer2","typeInterface","read","_data","_writer","reader2","length","encodeAddress","el","write8","decodeAddress","readBytes","encodeVector","writeVec","elementType","name2","params2","innerName","innerParams","decodeVector","readVec","fields","internalName","struct","freeze","canonicalOrder","structName","encodeStruct","fieldType","fieldParams","includes","paramIdx","indexOf","decodeStruct","result","fieldName","variants","canonicalTypeParams","encodeEnum","join","orderByte","invariant","invariantType","paramIndex","typeOrParam","decodeEnum","readULEB","get","chain","push","typeName2","left","right","genericSeparators","l_bound","r_bound","from","reverse","slice","BCS","U8","U16","U32","U64","U128","U256","BOOL","VECTOR","STRING","HEX","BASE58","BASE64","bcs","read8","u8","write16","read16","u16","write32","read32","u32","write64","read64","write128","read128","write256","read256","toString","charCodeAt","fromCharCode","Number","_str","bytes","Uint8Array","getRustConfig","getSuiMoveConfig"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/bcs/src/legacy-registry.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { BcsType } from './bcs-type.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport type { Encoding } from './types.js';\nimport { decodeStr, splitGenericParameters } from './utils.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nexport interface TypeInterface {\n\tencode: (\n\t\tself: BCS,\n\t\tdata: any,\n\t\toptions: BcsWriterOptions | undefined,\n\t\ttypeParams: TypeName[],\n\t) => BcsWriter;\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n\t_encodeRaw: (\n\t\twriter: BcsWriter,\n\t\tdata: any,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => BcsWriter;\n\t_decodeRaw: (\n\t\treader: BcsReader,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n\t/**\n\t * Defines type name for the vector / array type.\n\t * In Move: `vector<T>` or `vector`.\n\t */\n\tvectorType: string;\n\t/**\n\t * Address length. Varies depending on a platform and\n\t * has to be specified for the `address` type.\n\t */\n\taddressLength: number;\n\n\t/**\n\t * Custom encoding for address. Supported values are\n\t * either 'hex' or 'base64'.\n\t */\n\taddressEncoding?: 'hex' | 'base64';\n\t/**\n\t * Opening and closing symbol for type parameters. Can be\n\t * any pair of symbols (eg `['(', ')']`); default value follows\n\t * Rust and Move: `<` and `>`.\n\t */\n\tgenericSeparators?: [string, string];\n\t/**\n\t * Type definitions for the BCS. This field allows spawning\n\t * BCS instance from JSON or another prepared configuration.\n\t * Optional.\n\t */\n\ttypes?: {\n\t\tstructs?: { [key: string]: StructTypeDefinition };\n\t\tenums?: { [key: string]: EnumTypeDefinition };\n\t\taliases?: { [key: string]: string };\n\t};\n\t/**\n\t * Whether to auto-register primitive types on launch.\n\t */\n\twithPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n\t// Predefined types constants\n\tstatic readonly U8 = 'u8';\n\tstatic readonly U16 = 'u16';\n\tstatic readonly U32 = 'u32';\n\tstatic readonly U64 = 'u64';\n\tstatic readonly U128 = 'u128';\n\tstatic readonly U256 = 'u256';\n\tstatic readonly BOOL = 'bool';\n\tstatic readonly VECTOR = 'vector';\n\tstatic readonly ADDRESS = 'address';\n\tstatic readonly STRING = 'string';\n\tstatic readonly HEX = 'hex-string';\n\tstatic readonly BASE58 = 'base58-string';\n\tstatic readonly BASE64 = 'base64-string';\n\n\t/**\n\t * Map of kind `TypeName => TypeInterface`. Holds all\n\t * callbacks for (de)serialization of every registered type.\n\t *\n\t * If the value stored is a string, it is treated as an alias.\n\t */\n\tpublic types: Map<string, TypeInterface | string> = new Map();\n\n\t/**\n\t * Stored BcsConfig for the current instance of BCS.\n\t */\n\tprotected schema: BcsConfig;\n\n\t/**\n\t * Count temp keys to generate a new one when requested.\n\t */\n\tprotected counter: number = 0;\n\n\t/**\n\t * Name of the key to use for temporary struct definitions.\n\t * Returns a temp key + index (for a case when multiple temp\n\t * structs are processed).\n\t */\n\tprivate tempKey() {\n\t\treturn `bcs-struct-${++this.counter}`;\n\t}\n\n\t/**\n\t * Construct a BCS instance with a prepared schema.\n\t *\n\t * @param schema A prepared schema with type definitions\n\t * @param withPrimitives Whether to register primitive types by default\n\t */\n\tconstructor(schema: BcsConfig | BCS) {\n\t\t// if BCS instance is passed -> clone its schema\n\t\tif (schema instanceof BCS) {\n\t\t\tthis.schema = schema.schema;\n\t\t\tthis.types = new Map(schema.types);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.schema = schema;\n\n\t\t// Register address type under key 'address'.\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n\t\tthis.registerVectorType(schema.vectorType);\n\n\t\t// Register struct types if they were passed.\n\t\tif (schema.types && schema.types.structs) {\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register enum types if they were passed.\n\t\tif (schema.types && schema.types.enums) {\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register aliases if they were passed.\n\t\tif (schema.types && schema.types.aliases) {\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (schema.withPrimitives !== false) {\n\t\t\tregisterPrimitives(this);\n\t\t}\n\t}\n\n\t/**\n\t * Serialize data into bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<u8>', 'u8');\n\t *\n\t * let serialized = BCS\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\n\t *   .toBytes();\n\t *\n\t * console.assert(toHex(serialized) === '06010203040506');\n\t *\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\n\t * @param data Data to serialize.\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n\t */\n\tpublic ser(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: any,\n\t\toptions?: BcsWriterOptions,\n\t): BcsWriter {\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\n\t\t}\n\n\t\t// Quick serialization without registering the type in the main struct.\n\t\tif (typeof type === 'object') {\n\t\t\tconst key = this.tempKey();\n\t\t\tconst temp = new BCS(this);\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Deserialize BCS into a JS type.\n\t *\n\t * @example\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\n\t * let deNum = bcs.de('u64', num, 'hex');\n\t * console.assert(deNum.toString(10) === '4294967295');\n\t *\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n\t * @param data Data to deserialize.\n\t * @param encoding Optional - encoding to use if data is of type String\n\t * @return Deserialized data.\n\t */\n\tpublic de(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: Uint8Array | string,\n\t\tencoding?: Encoding,\n\t): any {\n\t\tif (typeof data === 'string') {\n\t\t\tif (encoding) {\n\t\t\t\tdata = decodeStr(data, encoding);\n\t\t\t} else {\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\n\t\t\t}\n\t\t}\n\n\t\t// In case the type specified is already registered.\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\n\t\t}\n\n\t\t// Deserialize without registering a type using a temporary clone.\n\t\tif (typeof type === 'object') {\n\t\t\tconst temp = new BCS(this);\n\t\t\tconst key = this.tempKey();\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\n\t * @param type Name of the type to check.\n\t * @returns\n\t */\n\tpublic hasType(type: string): boolean {\n\t\treturn this.types.has(type);\n\t}\n\n\t/**\n\t * Create an alias for a type.\n\t * WARNING: this can potentially lead to recursion\n\t * @param name Alias to use\n\t * @param forType Type to reference\n\t * @returns\n\t *\n\t * @example\n\t * ```\n\t * let bcs = new BCS(getSuiMoveConfig());\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n\t * ```\n\t */\n\tpublic registerAlias(name: string, forType: string): BCS {\n\t\tthis.types.set(name, forType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register new types for BCS internal representation.\n\t * For each registered type 2 callbacks must be specified and one is optional:\n\t *\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n\t * - validateCb(data) - validate data - either return bool or throw an error\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('number_string',\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n\t * );\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param encodeCb Callback to encode a value.\n\t * @param decodeCb Callback to decode a value.\n\t * @param validateCb Optional validator Callback to check type before serialization.\n\t */\n\tpublic registerType(\n\t\ttypeName: TypeName,\n\t\tencodeCb: (\n\t\t\twriter: BcsWriter,\n\t\t\tdata: any,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => BcsWriter,\n\t\tdecodeCb: (\n\t\t\treader: BcsReader,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => any,\n\t\tvalidateCb: (data: any) => boolean = () => true,\n\t): BCS {\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\n\n\t\tthis.types.set(name, {\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n\t\t\t},\n\t\t\tdecode(self: BCS, data, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n\t\t\t},\n\n\t\t\t// these methods should always be used with caution as they require pre-defined\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\n\t\t\t\tif (validateCb(data)) {\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\n\t\t\t},\n\t\t} as TypeInterface);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register BcsType instances to the registry\n\t * Types are registered with a callback that provides BcsType instances for each generic\n\t * passed to the type.\n\t *\n\t * - createType(...generics) - Return a BcsType instance\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('Box<T>', (T) => {\n\t * \t\treturn bcs.struct({\n\t * \t\t\tvalue: T\n\t * \t\t});\n\t * });\n\n\t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param createType a Callback to create the BcsType with any passed in generics\n\t */\n\tpublic registerBcsType(\n\t\ttypeName: TypeName,\n\t\tcreateType: (...params: BcsType<any>[]) => BcsType<any>,\n\t) {\n\t\tthis.registerType(\n\t\t\ttypeName,\n\t\t\t(writer, data, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._encodeRaw.call(this, writer, data, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: () => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tcreateType(...generics).write(data, writer);\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\t(reader, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (_data, _writer) => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: (reader) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\treturn createType(...generics).read(reader);\n\t\t\t},\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register an address type which is a sequence of U8s of specified length.\n\t * @example\n\t * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n\t *\n\t * @param name Name of the address type.\n\t * @param length Byte length of the address.\n\t * @param encoding Encoding to use for the address type\n\t * @returns\n\t */\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\n\t\tswitch (encoding) {\n\t\t\tcase 'base64':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tcase 'hex':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\n\t\t}\n\t}\n\n\t/**\n\t * Register custom vector type inside the bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<T>'); // generic registration\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n\t *\n\t * @param name Name of the type to register\n\t * @param elementType Optional name of the inner type of the vector\n\t * @return Returns self for chaining.\n\t */\n\tprivate registerVectorType(typeName: string): BCS {\n\t\tlet { name, params } = this.parseTypeName(typeName);\n\t\tif (params.length > 1) {\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\n\t\t}\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeVector(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: any[],\n\t\t\t\ttypeParams: TypeName[],\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tel,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\treturn reader.readVec((reader) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\treader,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register a custom Move struct. The first argument is a name of the\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\n\t * and the second is a struct description passed as an Object.\n\t *\n\t * The description object MUST have the same order on all of the platforms (ie in Move\n\t * or in Rust).\n\t *\n\t * @example\n\t * // Move / Rust struct\n\t * // struct Coin {\n\t * //   value: u64,\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\n\t * //   is_locked: bool,\n\t * // }\n\t *\n\t * bcs.registerStructType('Coin', {\n\t *   value: bcs.U64,\n\t *   owner: bcs.STRING,\n\t *   is_locked: bcs.BOOL\n\t * });\n\t *\n\t * // Created in Rust with diem/bcs\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n\t *  128, 209, 177,   5,  96,  0,  0,\n\t *    0,  14,  66, 105, 103, 32, 87,\n\t *   97, 108, 108, 101, 116, 32, 71,\n\t *  117, 121,   0\n\t * ];\n\t *\n\t * // Let's encode the value as well\n\t * let test_set = bcs.ser('Coin', {\n\t *   owner: 'Big Wallet Guy',\n\t *   value: '412412400000',\n\t *   is_locked: false,\n\t * });\n\t *\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n\t *\n\t * @param name Name of the type to register.\n\t * @param fields Fields of the struct. Must be in the correct order.\n\t * @return Returns BCS for chaining.\n\t */\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in fields) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = fields[key];\n\n\t\t\t// TODO: add a type guard here?\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tfields[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\n\t\t// struct so we maintain it and allow developers to use any field ordering in\n\t\t// their code (and not cause mismatches based on field order).\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Holds generics for the struct definition. At this stage we can check that\n\t\t// generic parameter matches the one defined in the struct.\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\n\n\t\t// Make sure all the types in the fields description are already known\n\t\t// and that all the field types are strings.\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeStruct(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data || data.constructor !== Object) {\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\n\t\t\t\t}\n\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// follow the canonical order when serializing\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tif (!(key in data)) {\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Before deserializing, read the canonical field type.\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\n\t\t\t\t\t// If not - tread as a regular field.\n\t\t\t\t\tif (!generics.includes(fieldType)) {\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tfieldParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\t\tparams as string[],\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet result: { [key: string]: any } = {};\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// if it's not a generic\n\t\t\t\t\tif (!generics.includes(fieldName)) {\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tfieldParams as string[],\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\n\t * @example\n\t * bcs.registerStructType('Coin', { value: 'u64' });\n\t * bcs.registerEnumType('MyEnum', {\n\t *  single: 'Coin',\n\t *  multi: 'vector<Coin>',\n\t *  empty: null\n\t * });\n\t *\n\t * console.log(\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n\t * )\n\t *\n\t * // and serialization\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n\t *\n\t * @param name\n\t * @param variants\n\t */\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in variants) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = variants[key];\n\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tvariants[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeEnum(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any | null },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\n\t\t\t\t}\n\t\t\t\tif (typeof data !== 'object') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet key = Object.keys(data)[0];\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n\t\t\t\t}\n\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\t// write order byte\n\t\t\t\twriter.write8(orderByte);\n\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn writer;\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tlet orderByte = reader.readULEB();\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Encode an empty value for the enum.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn { [invariant]: true };\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Get a set of encoders/decoders for specific type.\n\t * Mainly used to define custom type de/serialization logic.\n\t *\n\t * @param type\n\t * @returns {TypeInterface}\n\t */\n\tpublic getTypeInterface(type: string): TypeInterface {\n\t\tlet typeInterface = this.types.get(type);\n\n\t\t// Special case - string means an alias.\n\t\t// Goes through the alias chain and tracks recursion.\n\t\tif (typeof typeInterface === 'string') {\n\t\t\tlet chain: string[] = [];\n\t\t\twhile (typeof typeInterface === 'string') {\n\t\t\t\tif (chain.includes(typeInterface)) {\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\n\t\t\t\t}\n\t\t\t\tchain.push(typeInterface);\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (typeInterface === undefined) {\n\t\t\tthrow new Error(`Type ${type} is not registered`);\n\t\t}\n\n\t\treturn typeInterface;\n\t}\n\n\t/**\n\t * Parse a type name and get the type's generics.\n\t * @example\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n\t * // typeName: Option\n\t * // typeParams: [ 'Coin<SUI>' ]\n\t *\n\t * @param name Name of the type to process\n\t * @returns Object with typeName and typeParams listed as Array\n\t */\n\tpublic parseTypeName(name: TypeName): {\n\t\tname: string;\n\t\tparams: TypeName[];\n\t} {\n\t\tif (Array.isArray(name)) {\n\t\t\tlet [typeName, ...params] = name;\n\t\t\treturn { name: typeName, params };\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\n\t\t}\n\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\n\n\t\tlet l_bound = name.indexOf(left);\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\n\n\t\t// if there are no generics - exit gracefully.\n\t\tif (l_bound === -1 && r_bound === -1) {\n\t\t\treturn { name: name, params: [] };\n\t\t}\n\n\t\t// if one of the bounds is not defined - throw an Error.\n\t\tif (l_bound === -1 || r_bound === -1) {\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\n\t\t}\n\n\t\tlet typeName = name.slice(0, l_bound);\n\t\tlet params = splitGenericParameters(\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\n\t\t\tthis.schema.genericSeparators,\n\t\t);\n\n\t\treturn { name: typeName, params };\n\t}\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n\tbcs.registerType(\n\t\tBCS.U8,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8();\n\t\t},\n\t\t(u8) => u8 < 256,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U16,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write16(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read16();\n\t\t},\n\t\t(u16) => u16 < 65536,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U32,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write32(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read32();\n\t\t},\n\t\t(u32) => u32 <= 4294967296n,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U64,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write64(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read64();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U128,\n\t\tfunction (writer: BcsWriter, data: bigint) {\n\t\t\treturn writer.write128(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read128();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U256,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write256(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read256();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BOOL,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8().toString(10) === '1';\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.STRING,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader\n\t\t\t\t.readVec((reader) => reader.read8())\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\n\t\t\t\t.join('');\n\t\t},\n\t\t(_str: string) => true,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.HEX,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toHEX(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE58,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB58(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE64,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB64(new Uint8Array(bytes));\n\t\t},\n\t);\n}\n\nexport function getRustConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'Vec',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'vector',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}