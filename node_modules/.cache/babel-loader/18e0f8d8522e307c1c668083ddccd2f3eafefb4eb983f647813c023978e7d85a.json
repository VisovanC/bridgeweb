{"ast":null,"code":"import { bcs, BCS as BcsRegistry, fromB58, fromB64, fromHEX, getSuiMoveConfig, toB58, toB64, toHEX } from \"@mysten/bcs\";\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nimport { TypeTagSerializer as TypeTagSerializer2 } from \"./type-tag-serializer.js\";\nfunction isPureArg(arg) {\n  return arg.Pure !== void 0;\n}\nconst bcsRegistry = new BcsRegistry({\n  ...getSuiMoveConfig(),\n  types: {\n    enums: {\n      \"Option<T>\": {\n        None: null,\n        Some: \"T\"\n      }\n    }\n  }\n});\nfunction unsafe_u64(options) {\n  return bcs.u64({\n    name: \"unsafe_u64\",\n    ...options\n  }).transform({\n    input: val => val,\n    output: val => Number(val)\n  });\n}\nfunction optionEnum(type) {\n  return bcs.enum(\"Option\", {\n    None: null,\n    Some: type\n  });\n}\nfunction enumKind(type) {\n  return type.transform({\n    input: val => ({\n      [val.kind]: val\n    }),\n    output: val => {\n      const key = Object.keys(val)[0];\n      return {\n        kind: key,\n        ...val[key]\n      };\n    }\n  });\n}\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n  input: val => typeof val === \"string\" ? fromHEX(normalizeSuiAddress(val)) : val,\n  output: val => normalizeSuiAddress(toHEX(val))\n});\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n  name: \"ObjectDigest\",\n  input: value => fromB58(value),\n  output: value => toB58(new Uint8Array(value))\n});\nconst SuiObjectRef = bcs.struct(\"SuiObjectRef\", {\n  objectId: Address,\n  version: bcs.u64(),\n  digest: ObjectDigest\n});\nconst SharedObjectRef = bcs.struct(\"SharedObjectRef\", {\n  objectId: Address,\n  initialSharedVersion: bcs.u64(),\n  mutable: bcs.bool()\n});\nconst ObjectArg = bcs.enum(\"ObjectArg\", {\n  ImmOrOwned: SuiObjectRef,\n  Shared: SharedObjectRef,\n  Receiving: SuiObjectRef\n});\nconst CallArg = bcs.enum(\"CallArg\", {\n  Pure: bcs.vector(bcs.u8()),\n  Object: ObjectArg,\n  ObjVec: bcs.vector(ObjectArg)\n});\nconst TypeTag = bcs.enum(\"TypeTag\", {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => TypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null\n});\nconst Argument = enumKind(bcs.enum(\"Argument\", {\n  GasCoin: null,\n  Input: bcs.struct(\"Input\", {\n    index: bcs.u16()\n  }),\n  Result: bcs.struct(\"Result\", {\n    index: bcs.u16()\n  }),\n  NestedResult: bcs.struct(\"NestedResult\", {\n    index: bcs.u16(),\n    resultIndex: bcs.u16()\n  })\n}));\nconst ProgrammableMoveCall = bcs.struct(\"ProgrammableMoveCall\", {\n  package: Address,\n  module: bcs.string(),\n  function: bcs.string(),\n  type_arguments: bcs.vector(TypeTag),\n  arguments: bcs.vector(Argument)\n}).transform({\n  input: data => {\n    const [pkg, module, fun] = data.target.split(\"::\");\n    const type_arguments = data.typeArguments.map(tag => TypeTagSerializer.parseFromStr(tag, true));\n    return {\n      package: normalizeSuiAddress(pkg),\n      module,\n      function: fun,\n      type_arguments,\n      arguments: data.arguments\n    };\n  },\n  output: data => {\n    return {\n      target: [data.package, data.module, data.function].join(\"::\"),\n      arguments: data.arguments,\n      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)\n    };\n  }\n});\nconst Transaction = enumKind(bcs.enum(\"Transaction\", {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: ProgrammableMoveCall,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: bcs.struct(\"TransferObjects\", {\n    objects: bcs.vector(Argument),\n    address: Argument\n  }),\n  /**\n   * Split `amount` from a `coin`.\n   */\n  SplitCoins: bcs.struct(\"SplitCoins\", {\n    coin: Argument,\n    amounts: bcs.vector(Argument)\n  }),\n  /**\n   * Merge Vector of Coins (`sources`) into a `destination`.\n   */\n  MergeCoins: bcs.struct(\"MergeCoins\", {\n    destination: Argument,\n    sources: bcs.vector(Argument)\n  }),\n  /**\n   * Publish a Move module.\n   */\n  Publish: bcs.struct(\"Publish\", {\n    modules: bcs.vector(bcs.vector(bcs.u8())),\n    dependencies: bcs.vector(Address)\n  }),\n  /**\n   * Build a vector of objects using the input arguments.\n   * It is impossible to construct a `vector<T: key>` otherwise,\n   * so this call serves a utility function.\n   */\n  MakeMoveVec: bcs.struct(\"MakeMoveVec\", {\n    type: optionEnum(TypeTag),\n    objects: bcs.vector(Argument)\n  }),\n  /**  */\n  Upgrade: bcs.struct(\"Upgrade\", {\n    modules: bcs.vector(bcs.vector(bcs.u8())),\n    dependencies: bcs.vector(Address),\n    packageId: Address,\n    ticket: Argument\n  })\n}));\nconst ProgrammableTransaction = bcs.struct(\"ProgrammableTransaction\", {\n  inputs: bcs.vector(CallArg),\n  transactions: bcs.vector(Transaction)\n});\nconst TransactionKind = bcs.enum(\"TransactionKind\", {\n  ProgrammableTransaction,\n  ChangeEpoch: null,\n  Genesis: null,\n  ConsensusCommitPrologue: null\n});\nconst TransactionExpiration = bcs.enum(\"TransactionExpiration\", {\n  None: null,\n  Epoch: unsafe_u64()\n});\nconst StructTag = bcs.struct(\"StructTag\", {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(TypeTag)\n});\nconst GasData = bcs.struct(\"GasData\", {\n  payment: bcs.vector(SuiObjectRef),\n  owner: Address,\n  price: bcs.u64(),\n  budget: bcs.u64()\n});\nconst TransactionDataV1 = bcs.struct(\"TransactionDataV1\", {\n  kind: TransactionKind,\n  sender: Address,\n  gasData: GasData,\n  expiration: TransactionExpiration\n});\nconst TransactionData = bcs.enum(\"TransactionData\", {\n  V1: TransactionDataV1\n});\nconst IntentScope = bcs.enum(\"IntentScope\", {\n  TransactionData: null,\n  TransactionEffects: null,\n  CheckpointSummary: null,\n  PersonalMessage: null\n});\nconst IntentVersion = bcs.enum(\"IntentVersion\", {\n  V0: null\n});\nconst AppId = bcs.enum(\"AppId\", {\n  Sui: null\n});\nconst Intent = bcs.struct(\"Intent\", {\n  scope: IntentScope,\n  version: IntentVersion,\n  appId: AppId\n});\nconst IntentMessage = bcs.generic([\"T\"], T => bcs.struct(\"IntentMessage<T>\", {\n  intent: Intent,\n  value: T\n}));\nconst CompressedSignature = bcs.enum(\"CompressedSignature\", {\n  ED25519: bcs.fixedArray(64, bcs.u8()),\n  Secp256k1: bcs.fixedArray(64, bcs.u8()),\n  Secp256r1: bcs.fixedArray(64, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst PublicKey = bcs.enum(\"PublicKey\", {\n  ED25519: bcs.fixedArray(32, bcs.u8()),\n  Secp256k1: bcs.fixedArray(33, bcs.u8()),\n  Secp256r1: bcs.fixedArray(33, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst MultiSigPkMap = bcs.struct(\"MultiSigPkMap\", {\n  pubKey: PublicKey,\n  weight: bcs.u8()\n});\nconst MultiSigPublicKey = bcs.struct(\"MultiSigPublicKey\", {\n  pk_map: bcs.vector(MultiSigPkMap),\n  threshold: bcs.u16()\n});\nconst MultiSig = bcs.struct(\"MultiSig\", {\n  sigs: bcs.vector(CompressedSignature),\n  bitmap: bcs.u16(),\n  multisig_pk: MultiSigPublicKey\n});\nconst base64String = bcs.vector(bcs.u8()).transform({\n  input: val => typeof val === \"string\" ? fromB64(val) : val,\n  output: val => toB64(new Uint8Array(val))\n});\nconst SenderSignedTransaction = bcs.struct(\"SenderSignedTransaction\", {\n  intentMessage: IntentMessage(TransactionData),\n  txSignatures: bcs.vector(base64String)\n});\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n  name: \"SenderSignedData\"\n});\nconst suiBcs = {\n  ...bcs,\n  U8: bcs.u8(),\n  U16: bcs.u16(),\n  U32: bcs.u32(),\n  U64: bcs.u64(),\n  U128: bcs.u128(),\n  U256: bcs.u256(),\n  ULEB128: bcs.uleb128(),\n  Bool: bcs.bool(),\n  String: bcs.string(),\n  Address,\n  Argument,\n  CallArg,\n  CompressedSignature,\n  GasData,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  Transaction,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag,\n  // preserve backwards compatibility with old bcs export\n  ser: bcsRegistry.ser.bind(bcsRegistry),\n  de: bcsRegistry.de.bind(bcsRegistry),\n  getTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n  hasType: bcsRegistry.hasType.bind(bcsRegistry),\n  parseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n  registerAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n  registerAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n  registerBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n  registerEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n  registerStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n  registerType: bcsRegistry.registerType.bind(bcsRegistry),\n  types: bcsRegistry.types\n};\nbcsRegistry.registerBcsType(\"utf8string\", () => bcs.string({\n  name: \"utf8string\"\n}));\nbcsRegistry.registerBcsType(\"unsafe_u64\", () => unsafe_u64());\nbcsRegistry.registerBcsType(\"enumKind\", T => enumKind(T));\n[Address, Argument, CallArg, CompressedSignature, GasData, MultiSig, MultiSigPkMap, MultiSigPublicKey, ObjectArg, ObjectDigest, ProgrammableMoveCall, ProgrammableTransaction, PublicKey, SenderSignedData, SharedObjectRef, StructTag, SuiObjectRef, Transaction, TransactionData, TransactionDataV1, TransactionExpiration, TransactionKind, TypeTag].forEach(type => {\n  bcsRegistry.registerBcsType(type.name, () => type);\n});\nexport { TypeTagSerializer2 as TypeTagSerializer, suiBcs as bcs, bcsRegistry, isPureArg };","map":{"version":3,"names":["bcs","BCS","BcsRegistry","fromB58","fromB64","fromHEX","getSuiMoveConfig","toB58","toB64","toHEX","normalizeSuiAddress","SUI_ADDRESS_LENGTH","TypeTagSerializer","TypeTagSerializer2","isPureArg","arg","Pure","bcsRegistry","types","enums","None","Some","unsafe_u64","options","u64","name","transform","input","val","output","Number","optionEnum","type","enum","enumKind","kind","key","Object","keys","Address","bytes","ObjectDigest","vector","u8","value","Uint8Array","SuiObjectRef","struct","objectId","version","digest","SharedObjectRef","initialSharedVersion","mutable","bool","ObjectArg","ImmOrOwned","Shared","Receiving","CallArg","ObjVec","TypeTag","u128","address","signer","lazy","StructTag","u16","u32","u256","Argument","GasCoin","Input","index","Result","NestedResult","resultIndex","ProgrammableMoveCall","package","module","string","function","type_arguments","arguments","data","pkg","fun","target","split","typeArguments","map","tag","parseFromStr","join","tagToString","Transaction","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","dependencies","MakeMoveVec","Upgrade","packageId","ticket","ProgrammableTransaction","inputs","transactions","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","TransactionExpiration","Epoch","typeParams","GasData","payment","owner","price","budget","TransactionDataV1","sender","gasData","expiration","TransactionData","V1","IntentScope","TransactionEffects","CheckpointSummary","PersonalMessage","IntentVersion","V0","AppId","Sui","Intent","scope","appId","IntentMessage","generic","T","intent","CompressedSignature","ED25519","fixedArray","Secp256k1","Secp256r1","ZkLogin","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","base64String","SenderSignedTransaction","intentMessage","txSignatures","SenderSignedData","suiBcs","U8","U16","U32","U64","U128","U256","ULEB128","uleb128","Bool","String","ser","bind","de","getTypeInterface","hasType","parseTypeName","registerAddressType","registerAlias","registerBcsType","registerEnumType","registerStructType","registerType","forEach"],"sources":["/home/cala/project/bridgeweb/node_modules/@mysten/sui.js/src/bcs/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport {\n\tbcs,\n\tBCS as BcsRegistry,\n\tfromB58,\n\tfromB64,\n\tfromHEX,\n\tgetSuiMoveConfig,\n\ttoB58,\n\ttoB64,\n\ttoHEX,\n} from '@mysten/bcs';\n\nimport type { MoveCallTransaction } from '../transactions/Transactions.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n\t/** Hex code as string representing the object id */\n\tobjectId: string;\n\n\t/** The version the object was shared at */\n\tinitialSharedVersion: number | string;\n\n\t/** Whether reference is mutable */\n\tmutable: boolean;\n};\n\nexport type SuiObjectRef = {\n\t/** Base64 string representing the object digest */\n\tobjectId: string;\n\t/** Object version */\n\tversion: number | string | bigint;\n\t/** Hex code as string representing the object id */\n\tdigest: string;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n\t| { ImmOrOwned: SuiObjectRef }\n\t| { Shared: SharedObjectRef }\n\t| { Receiving: SuiObjectRef };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n\treturn (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n\t| { bool: null | true }\n\t| { u8: null | true }\n\t| { u64: null | true }\n\t| { u128: null | true }\n\t| { address: null | true }\n\t| { signer: null | true }\n\t| { vector: TypeTag }\n\t| { struct: StructTag }\n\t| { u16: null | true }\n\t| { u32: null | true }\n\t| { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n\tpayment: SuiObjectRef[];\n\towner: string; // Gas Object's owner\n\tprice: number;\n\tbudget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\nconst bcsRegistry = new BcsRegistry({\n\t...getSuiMoveConfig(),\n\ttypes: {\n\t\tenums: {\n\t\t\t'Option<T>': {\n\t\t\t\tNone: null,\n\t\t\t\tSome: 'T',\n\t\t\t},\n\t\t},\n\t},\n});\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n\ttype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\ttype EnumKindTransform<T> = T extends infer U\n\t\t? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n\t\t: never;\n\n\treturn type.transform({\n\t\tinput: (val: EnumKindTransform<Input>) =>\n\t\t\t({\n\t\t\t\t[val.kind]: val,\n\t\t\t}) as Input,\n\t\toutput: (val) => {\n\t\t\tconst key = Object.keys(val)[0] as keyof T;\n\n\t\t\treturn { kind: key, ...val[key] } as EnumKindTransform<T>;\n\t\t},\n\t});\n}\n\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n});\n\nconst SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nconst SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nconst ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwned: SuiObjectRef,\n\tShared: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nconst CallArg = bcs.enum('CallArg', {\n\tPure: bcs.vector(bcs.u8()),\n\tObject: ObjectArg,\n\tObjVec: bcs.vector(ObjectArg),\n});\n\nconst TypeTag: BcsType<TypeTag> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => TypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as never;\n\nconst Argument = enumKind(\n\tbcs.enum('Argument', {\n\t\tGasCoin: null,\n\t\tInput: bcs.struct('Input', { index: bcs.u16() }),\n\t\tResult: bcs.struct('Result', { index: bcs.u16() }),\n\t\tNestedResult: bcs.struct('NestedResult', { index: bcs.u16(), resultIndex: bcs.u16() }),\n\t}),\n);\n\n/** Custom serializer for decoding package, module, function easier */\nconst ProgrammableMoveCall = bcs\n\t.struct('ProgrammableMoveCall', {\n\t\tpackage: Address,\n\t\tmodule: bcs.string(),\n\t\tfunction: bcs.string(),\n\t\ttype_arguments: bcs.vector(TypeTag),\n\t\targuments: bcs.vector(Argument),\n\t})\n\t.transform({\n\t\tinput: (data: MoveCallTransaction) => {\n\t\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t};\n\t\t},\n\t\toutput: (data) => {\n\t\t\treturn {\n\t\t\t\ttarget: [data.package, data.module, data.function].join(\n\t\t\t\t\t'::',\n\t\t\t\t) as `${string}::${string}::${string}`,\n\t\t\t\targuments: data.arguments,\n\t\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t\t};\n\t\t},\n\t});\n\nconst Transaction = enumKind(\n\tbcs.enum('Transaction', {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: ProgrammableMoveCall,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: bcs.struct('TransferObjects', {\n\t\t\tobjects: bcs.vector(Argument),\n\t\t\taddress: Argument,\n\t\t}),\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: bcs.struct('SplitCoins', { coin: Argument, amounts: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: bcs.struct('MergeCoins', { destination: Argument, sources: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: bcs.struct('Publish', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t}),\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\t\ttype: optionEnum(TypeTag),\n\t\t\tobjects: bcs.vector(Argument),\n\t\t}),\n\t\t/**  */\n\t\tUpgrade: bcs.struct('Upgrade', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t\tpackageId: Address,\n\t\t\tticket: Argument,\n\t\t}),\n\t}),\n);\n\nconst ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\ttransactions: bcs.vector(Transaction),\n});\n\nconst TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nconst TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nconst StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(TypeTag),\n});\n\nconst GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nconst TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nconst TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nconst IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nconst IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nconst AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nconst Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nconst IntentMessage = bcs.generic(['T'], (T) =>\n\tbcs.struct('IntentMessage<T>', {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t}),\n);\n\nconst CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nconst MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nconst MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nconst base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\toutput: (val) => toB64(new Uint8Array(val)),\n});\n\nconst SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\n\t// preserve backwards compatibility with old bcs export\n\tser: bcsRegistry.ser.bind(bcsRegistry),\n\tde: bcsRegistry.de.bind(bcsRegistry),\n\tgetTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n\thasType: bcsRegistry.hasType.bind(bcsRegistry),\n\tparseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n\tregisterAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n\tregisterAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n\tregisterBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n\tregisterEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n\tregisterStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n\tregisterType: bcsRegistry.registerType.bind(bcsRegistry),\n\ttypes: bcsRegistry.types,\n};\n\nbcsRegistry.registerBcsType('utf8string', () => bcs.string({ name: 'utf8string' }));\nbcsRegistry.registerBcsType('unsafe_u64', () => unsafe_u64());\nbcsRegistry.registerBcsType('enumKind', (T) => enumKind(T));\n\n[\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n].forEach((type) => {\n\tbcsRegistry.registerBcsType(type.name, () => type);\n});\n\nexport { suiBcs as bcs, bcsRegistry };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}